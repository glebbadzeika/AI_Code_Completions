[
    {
        "id": 0,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\n",
        "middle": "def count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image,",
        "suffix": " label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 1,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10",
        "middle": ", 6))\n ",
        "suffix": "   plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 2,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24",
        "middle": ", 1",
        "suffix": "2))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 3,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n   ",
        "middle": " plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i ",
        "suffix": "in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 4,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n           ",
        "middle": " plt.title(class_na",
        "suffix": "mes[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 5,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n   ",
        "middle": " plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels i",
        "suffix": "n data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 6,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\"",
        "middle": ", report)",
        "suffix": ""
    },
    {
        "id": 7,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy",
        "middle": "()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, targe",
        "suffix": "t_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 8,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label)",
        "middle": ", str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, ",
        "suffix": "target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 9,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection ",
        "middle": "import ",
        "suffix": "train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 10,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded ",
        "middle": "= label_encoder.transform(y_t",
        "suffix": "est)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 11,
        "filename": "2.txt",
        "prefix": "import xgboost as ",
        "middle": "xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfr",
        "suffix": "om sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 12,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            ",
        "middle": "media_dir = 'static/media/'\n                            os.mak",
        "suffix": "edirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 13,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n             ",
        "middle": "   offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while Tru",
        "suffix": "e:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 14,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self",
        "middle": "):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nvie",
        "suffix": "wer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 15,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                      ",
        "middle": "          if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n            ",
        "suffix": "                        print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 16,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to ",
        "middle": "exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        pr",
        "suffix": "int('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 17,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                    ",
        "middle": "      ",
        "suffix": "          'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    }
]