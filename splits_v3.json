[
    {
        "id": 0,
        "filename": "8.txt",
        "prefix": "\n\"\"\"Pixel Sorting\"\"\"\n\n# Importing Libraries\nimport cv2\nimport numpy as np\nimport math\nimport colorsys\nimport pandas as pd\nimport os\nimport argparse\nfrom tqdm import tqdm\n\n# Importing the external file Library\nimport sound\n\n# Taking arguments from command line\nparser = argparse.ArgumentParser()  # you iniatize as such\nparser.add_argument(\"-f\", required=True, help=\"enter fileName of your picture\")\n# parser.add_argument(\"-s\", required=True, help=\"Speed factor of the audio to be increased or decreased\")\n# parser.add_argument(\"-av\", required=True, help=\"Speed factor of the audio visualizer to be increased or decreased\")\n\n# the add_argument tells you what needs to be given as an input sp its help\nargs = parser.parse_args()  # you take the arguments from command line\n\nos.makedirs(\"Image_sort/\" + str(args.f))\nprint(str(args.f).capitalize() + \" directory is created.\")\n\n# Defining all global variables\ndf = []\ntotal = 0\ndict, final, img_list = {}, [], []\n\n# Create dataframe and save it as an excel file\ndef createDataSet(val=0, data=[]):\n    global dict\n    dict[len(data)] = data\n    if val != 0:\n        if val == max(dict.keys()):\n            final_df = pd.DataFrame(dict[val], columns=[\"Blue\", \"Green\", \"Red\"])\n            final_df.to_excel(\"Image_sort/\" + str(args.f) + \"/\" + \"output.xlsx\")\n\n\n# Generating colors for each row of the frame\ndef generateColors(c_sorted, frame, row):\n    global df, img_list\n    height = 15\n    img = np.zeros((height, len(c_sorted), 3), np.uint8)\n    for x in range(0, len(c_sorted)):\n        r, g, b = c_sorted[x][0] * 255, c_sorted[x][1] * 255, c_sorted[x][2] * 255\n        c = [r, g, b]\n        df.append(c)\n        img[:, x] = c  # the color value for the xth column , this gives the color band\n        frame[row, x] = c  # changes added for every row in the frame\n\n    createDataSet(data=df)\n    return img, frame\n\n\n# Measures the total number of pixels that were involved in pixel sort\ndef measure(count, row, col, height, width):\n    global total\n    total += count\n    if row == height - 1 and col == width - 1:\n        createDataSet(val=total)\n\n\n# Step Sorting Algorithm\ndef step(bgr, repetitions=1):\n    b, g, r = bgr\n    # lum is calculated as per the way the humans view the colors\n    lum = math.sqrt(0.241 * r + 0.691 * g + 0.068 * b)\n\n    # conversion of rgb to hsv values\n    h, s, v = colorsys.rgb_to_hsv(\n        r, g, b\n    )  # h,s,v is a better option for classifying each color\n\n    # Repetitions are taken to decrease the noise\n    h2 = int(h * repetitions)\n    v2 = int(v * repetitions)\n\n    # To get a smoother color band\n    if h2 % 2 == 1:\n        v2 = repetitions - v2\n        lum = repetitions - lum\n\n    return h2, lum, v2\n\n\n# Threshold set for avoiding extreme sorting of the pixels\ndef findThreshold(lst, add):\n    for i in lst:\n        add.append(sum(i))\n    return (max(add) + min(add)) / 2\n\n\ndef makeVideo():\n    out = cv2.VideoWriter(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".mp4\",\n        cv2.VideoWriter_fourcc(*\"mp4v\"),\n        16,\n        (800, 500),\n    )\n    for count in tqdm(range(1, 500 + 1)):\n        fileName = \"Image_sort/\" + str(args.f) + \"/\" + str(count) + \".jpg\"\n        img = cv2.imread(fileName)\n        out.write(img)\n        os.remove(fileName)\n    out.release()\n\n\ndef main():\n    global img_list\n    img = cv2.imread(\"Image/\" + str(args.f) + \".jpg\")\n    img = cv2.resize(img, (800, 500))\n    img_list.append(img)\n\n    height, width, _ = img.shape\n    print(\">>> Row-wise Color sorting\")\n    for row in tqdm(range(0, height)):\n        color, color_n = [], []\n        add = []\n\n        for col in range(0, width):\n            val = img[row][col].tolist()\n\n            # val includes all rgb values between the range of 0 to 1\n            # This makes the sorting easier and efficient\n            val = [i / 255.0 for i in val]\n            color.append(val)\n\n        thresh = findThreshold(\n            color, add\n        )  # setting the threshold value for every",
        "middle": " row ",
        "suffix": "in the frame\n\n        # For the specific row , if all the values are non-zero then it is sorted with color\n        if np.all(np.asarray(color)) == True:\n            color.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color, img, row)\n            measure(len(color), row, col, height, width)\n\n        # For the specific row , if any of the values are zero it gets sorted with color_n\n        if np.all(np.asarray(color)) == False:\n            for ind, i in enumerate(color):\n                # Accessing every list within color\n                # Added to color_n if any of the element in the list is non-zero\n                # and their sum is less than threshold  value\n\n                if np.any(np.asarray(i)) == True and sum(i) < thresh:\n                    color_n.append(i)\n\n            color_n.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color_n, img, row)\n            measure(len(color_n), row, col, height, width)\n        cv2.imwrite(\"Image_sort/\" + str(args.f) + \"/\" + str(row + 1) + \".jpg\", img)\n\n    # Writing down the final sorted image\n    cv2.imwrite(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".jpg\", img\n    )  # Displaying the final picture\n\n    print(\"\\n>>> Formation of the Video progress of the pixel-sorted image\")\n    makeVideo()\n    sound.main(\n        args.f\n    )  # Calling the external python file to create the audio of the pixel-sorted image\n\n\nmain()\n"
    },
    {
        "id": 1,
        "filename": "8.txt",
        "prefix": "\n\"\"\"Pixel Sorting\"\"\"\n\n# Importing Libraries\nimport cv2\nimport numpy as np\nimport math\nimport colorsys\nimport pandas as pd\nimport os\nimport argparse\nfrom tqdm import tqdm\n\n# Importing the external file Library\nimport sound\n\n# Taking arguments from command line\nparser = argparse.ArgumentParser()  # you iniatize as such\nparser.add_argument(\"-f\", required=True, help=\"enter fileName of your picture\")\n# parser.add_argument(\"-s\", required=True, help=\"Speed factor of the audio to be increased or decreased\")\n# parser.add_argument(\"-av\", required=True, help=\"Speed factor of the audio visualizer to be increased or decreased\")\n\n# the add_argument tells you what needs to be given as an input sp its help\nargs = parser.parse_args()  # you take the arguments from command line\n\nos.makedirs(\"Image_sort/\" + str(args.f))\nprint(str(args.f).capitalize() + \" directory is created.\")\n\n# Defining all global variables\ndf = []\ntotal = 0\ndict, final, img_list = {}, [], []\n\n# Create dataframe and save it as an excel file\ndef createDataSet(val=0, data=[]):\n    global dict\n    dict[len(data)] = data\n    if val != 0:\n        if val == max(dict.keys()):\n            final_df = pd.DataFrame(dict[val], columns=[\"Blue\", \"Green\", \"Red\"])\n            final_df.to_excel(\"Image_sort/\" + str(args.f) + \"/\" + \"output.xlsx\")\n\n\n# Generating colors for each row of the frame\ndef generateColors(c_sorted, frame, row):\n    global df, img_list\n    height = 15\n    img = np.zeros((height, len(c_sorted), 3), np.uint8)\n    for x in range(0, len",
        "middle": "(c_sorted))",
        "suffix": ":\n        r, g, b = c_sorted[x][0] * 255, c_sorted[x][1] * 255, c_sorted[x][2] * 255\n        c = [r, g, b]\n        df.append(c)\n        img[:, x] = c  # the color value for the xth column , this gives the color band\n        frame[row, x] = c  # changes added for every row in the frame\n\n    createDataSet(data=df)\n    return img, frame\n\n\n# Measures the total number of pixels that were involved in pixel sort\ndef measure(count, row, col, height, width):\n    global total\n    total += count\n    if row == height - 1 and col == width - 1:\n        createDataSet(val=total)\n\n\n# Step Sorting Algorithm\ndef step(bgr, repetitions=1):\n    b, g, r = bgr\n    # lum is calculated as per the way the humans view the colors\n    lum = math.sqrt(0.241 * r + 0.691 * g + 0.068 * b)\n\n    # conversion of rgb to hsv values\n    h, s, v = colorsys.rgb_to_hsv(\n        r, g, b\n    )  # h,s,v is a better option for classifying each color\n\n    # Repetitions are taken to decrease the noise\n    h2 = int(h * repetitions)\n    v2 = int(v * repetitions)\n\n    # To get a smoother color band\n    if h2 % 2 == 1:\n        v2 = repetitions - v2\n        lum = repetitions - lum\n\n    return h2, lum, v2\n\n\n# Threshold set for avoiding extreme sorting of the pixels\ndef findThreshold(lst, add):\n    for i in lst:\n        add.append(sum(i))\n    return (max(add) + min(add)) / 2\n\n\ndef makeVideo():\n    out = cv2.VideoWriter(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".mp4\",\n        cv2.VideoWriter_fourcc(*\"mp4v\"),\n        16,\n        (800, 500),\n    )\n    for count in tqdm(range(1, 500 + 1)):\n        fileName = \"Image_sort/\" + str(args.f) + \"/\" + str(count) + \".jpg\"\n        img = cv2.imread(fileName)\n        out.write(img)\n        os.remove(fileName)\n    out.release()\n\n\ndef main():\n    global img_list\n    img = cv2.imread(\"Image/\" + str(args.f) + \".jpg\")\n    img = cv2.resize(img, (800, 500))\n    img_list.append(img)\n\n    height, width, _ = img.shape\n    print(\">>> Row-wise Color sorting\")\n    for row in tqdm(range(0, height)):\n        color, color_n = [], []\n        add = []\n\n        for col in range(0, width):\n            val = img[row][col].tolist()\n\n            # val includes all rgb values between the range of 0 to 1\n            # This makes the sorting easier and efficient\n            val = [i / 255.0 for i in val]\n            color.append(val)\n\n        thresh = findThreshold(\n            color, add\n        )  # setting the threshold value for every row in the frame\n\n        # For the specific row , if all the values are non-zero then it is sorted with color\n        if np.all(np.asarray(color)) == True:\n            color.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color, img, row)\n            measure(len(color), row, col, height, width)\n\n        # For the specific row , if any of the values are zero it gets sorted with color_n\n        if np.all(np.asarray(color)) == False:\n            for ind, i in enumerate(color):\n                # Accessing every list within color\n                # Added to color_n if any of the element in the list is non-zero\n                # and their sum is less than threshold  value\n\n                if np.any(np.asarray(i)) == True and sum(i) < thresh:\n                    color_n.append(i)\n\n            color_n.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color_n, img, row)\n            measure(len(color_n), row, col, height, width)\n        cv2.imwrite(\"Image_sort/\" + str(args.f) + \"/\" + str(row + 1) + \".jpg\", img)\n\n    # Writing down the final sorted image\n    cv2.imwrite(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".jpg\", img\n    )  # Displaying the final picture\n\n    print(\"\\n>>> Formation of the Video progress of the pixel-sorted image\")\n    makeVideo()\n    sound.main(\n        args.f\n    )  # Calling the external python file to create the audio of the pixel-sorted image\n\n\nmain()\n"
    },
    {
        "id": 2,
        "filename": "8.txt",
        "prefix": "\n\"\"\"Pixel Sorting\"\"\"\n\n# Importing Libraries\nimport cv2\nimport numpy as np\nimport math\nimport colorsys\nimport pandas as pd\nimport os\nimport argparse\nfrom tqdm import tqdm\n\n# Importing the external file Library\nimport sound\n\n# Taking arguments from command line\nparser = argparse.ArgumentParser()  # you iniatize as such\nparser.add_argument(\"-f\", required=True, help=\"enter fileName of your picture\")\n# parser.add_argument(\"-s\", required=True, help=\"Speed factor of the audio to be increased or decreased\")\n# parser.add_argument(\"-av\", required=True, help=\"Speed factor of the audio visualizer to be increased or decreased\")\n\n# the add_argument tells you what needs to be given as an input sp its help\nargs = parser.parse_args()  # you take the arguments from command line\n\nos.makedirs(\"Image_sort/\" + str(args.f))\nprint(str(args.f).capitalize() + \" directory is created.\")\n\n# Defining all global variables\ndf = []\ntotal = 0\ndict, final, img_list = {}, [], []\n\n# Create dataframe and save it as an excel file\ndef createDataSet(val=0, data=[]):\n    global dict\n    dict[len(data)] = data\n    if val != 0:\n        if val == max(dict.keys()):\n            final_df = pd.DataFrame(dict[val], columns=[\"Blue\", \"Green\", \"Red\"])\n            final_df.to_excel(\"Image_sort/\" + str(args.f) + \"/\" + \"output.xlsx\")\n\n\n# Generating colors for each row of the frame\ndef generateColors(c_sorted, frame, row):\n    global df, img_list\n    height = 15\n    img = np.zeros((height, len(c_sorted), 3), np.uint8)\n    for x in range(0, len(c_sorted)):\n        r, g, b = c_sorted[x][0] * 255, c_sorted[x][1] * 255, c_sorted[x][2] * 255\n        c = [r, g, b]\n        df.append(c)\n        img[:, x] = c  # the color value for the xth column , this gives the color band\n        frame[row, x] = c  # changes added for every row in the frame\n\n    createDataSet(data=df)\n    return img, frame\n\n\n# Measures the total number of pixels that were involved in pixel sort\ndef measure(count, row, col, height, width):\n    global total\n    total += count\n    if row == height - 1 and col == width - 1:\n        createDataSet(val=total)\n\n\n# Step Sorting Algorithm\ndef step(bgr, repetitions=1):\n    b, g, r = bgr\n    # lum is calculated as per the way the humans view the colors\n    lum = math.sqrt(0.241 * r + 0.691 * g + 0.068 * b)\n\n    # conversion of rgb to hsv values\n    h, s, v = colorsys.rgb_to_hsv(\n        r, g, b\n    )  # h,s,v is a better option for classifying each color\n\n    # Repetitions are taken to decrease the noise\n    h2 = int(h * repetitions)\n    v2 = int(v * repetitions)\n\n    # To get a smoother color band\n    if h2 % 2 == 1:\n        v2 = repetitions - v2\n        lum = repetitions - lum\n\n    return h2, lum, v2\n\n\n# Threshold set for avoiding extreme sorting of the pixels\ndef findThreshold(lst, add):\n    for i in lst:\n        add.append(sum(i))\n    return (max(add) + min(add)) / 2\n\n\ndef makeVideo():\n    out = cv2.VideoWriter(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".mp4\",\n        cv2.VideoWriter_fourcc(*\"mp4v\"),\n        16,\n        (800, 500),\n    )\n    for count in tqdm(range(1, 500 + 1)):\n        fileName = \"Image_sort/\" + str(args.f) + \"/\" + str(count) + \".jpg\"\n        img = cv2.imread(fileName)\n        out.write(img)\n        os.remove(fileName)\n    out.release()\n\n\ndef main():\n    global img_list\n    img = cv2.imread(\"Image/\" + str(args.f) + \".jpg\")\n    img = cv2.resize(img, (800, 500))\n    img_list.append(img)\n\n    height, width, _ = img.shape\n    print(\">>> Row-wise Color sorting\")\n    for row in tqdm(range(0, height)):\n        color, color_n = [], []\n        add = []\n\n        for col in range(0, width):\n            val = img[row][col].tolist()\n\n            # val includes all rgb values between the range of 0 to 1\n            # This makes the sorting easier and efficient\n            val = [i / 255.0 for i in val]\n            color.append(val)\n\n        thresh = findThreshold(\n            color, add\n        )  # setting the threshold value for every row in the frame\n\n        # For the specific row , if all the values are non-zero then it is sorted with color\n        if np.all(np.asarray(color)) == True:\n            color.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color, img, row)\n            measure(len(color), row, col, height, width)\n\n        # For the specific row , if any of the values are zero it gets sorted with color_n\n        if np.all(np.asarray(color)) == False:\n            for ind, i in enumerate(color):\n                # Accessing every list within color\n                # Added to color_n if any of the element in the list is non-zero\n                # and their sum is less than threshold  ",
        "middle": "value\n\n                if np.any(np.asarray(i)) == True and sum(i) < ",
        "suffix": "thresh:\n                    color_n.append(i)\n\n            color_n.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color_n, img, row)\n            measure(len(color_n), row, col, height, width)\n        cv2.imwrite(\"Image_sort/\" + str(args.f) + \"/\" + str(row + 1) + \".jpg\", img)\n\n    # Writing down the final sorted image\n    cv2.imwrite(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".jpg\", img\n    )  # Displaying the final picture\n\n    print(\"\\n>>> Formation of the Video progress of the pixel-sorted image\")\n    makeVideo()\n    sound.main(\n        args.f\n    )  # Calling the external python file to create the audio of the pixel-sorted image\n\n\nmain()\n"
    },
    {
        "id": 3,
        "filename": "8.txt",
        "prefix": "\n\"\"\"Pixel Sorting\"\"\"\n\n# Importing Libraries\nimport cv2\nimport numpy as np\nimport math\nimport colorsys\nimport pandas as pd\nimport os\nimport argparse\nfrom tqdm import tqdm\n\n# Importing the external file Library\nimport sound\n\n# Taking arguments from command line\nparser = argparse.ArgumentParser()  # you iniatize as such\nparser.add_argument(\"-f\", required=True, help=\"enter fileName of your picture\")\n# parser.add_argument(\"-s\", required=True, help=\"Speed factor of the audio to be increased or decreased\")\n# parser.add_argument(\"-av\", required=True, help=\"Speed factor of the audio visualizer to be increased or decreased\")\n\n# the add_argument tells you what needs to be given as an input sp its help\nargs = parser.parse_args()  # you take the arguments from command line\n\nos.makedirs(\"Image_sort/\" + str(args.f))\nprint(str(args.f).capitalize() + \" directory is created",
        "middle": ".\")\n\n# Defining all global ",
        "suffix": "variables\ndf = []\ntotal = 0\ndict, final, img_list = {}, [], []\n\n# Create dataframe and save it as an excel file\ndef createDataSet(val=0, data=[]):\n    global dict\n    dict[len(data)] = data\n    if val != 0:\n        if val == max(dict.keys()):\n            final_df = pd.DataFrame(dict[val], columns=[\"Blue\", \"Green\", \"Red\"])\n            final_df.to_excel(\"Image_sort/\" + str(args.f) + \"/\" + \"output.xlsx\")\n\n\n# Generating colors for each row of the frame\ndef generateColors(c_sorted, frame, row):\n    global df, img_list\n    height = 15\n    img = np.zeros((height, len(c_sorted), 3), np.uint8)\n    for x in range(0, len(c_sorted)):\n        r, g, b = c_sorted[x][0] * 255, c_sorted[x][1] * 255, c_sorted[x][2] * 255\n        c = [r, g, b]\n        df.append(c)\n        img[:, x] = c  # the color value for the xth column , this gives the color band\n        frame[row, x] = c  # changes added for every row in the frame\n\n    createDataSet(data=df)\n    return img, frame\n\n\n# Measures the total number of pixels that were involved in pixel sort\ndef measure(count, row, col, height, width):\n    global total\n    total += count\n    if row == height - 1 and col == width - 1:\n        createDataSet(val=total)\n\n\n# Step Sorting Algorithm\ndef step(bgr, repetitions=1):\n    b, g, r = bgr\n    # lum is calculated as per the way the humans view the colors\n    lum = math.sqrt(0.241 * r + 0.691 * g + 0.068 * b)\n\n    # conversion of rgb to hsv values\n    h, s, v = colorsys.rgb_to_hsv(\n        r, g, b\n    )  # h,s,v is a better option for classifying each color\n\n    # Repetitions are taken to decrease the noise\n    h2 = int(h * repetitions)\n    v2 = int(v * repetitions)\n\n    # To get a smoother color band\n    if h2 % 2 == 1:\n        v2 = repetitions - v2\n        lum = repetitions - lum\n\n    return h2, lum, v2\n\n\n# Threshold set for avoiding extreme sorting of the pixels\ndef findThreshold(lst, add):\n    for i in lst:\n        add.append(sum(i))\n    return (max(add) + min(add)) / 2\n\n\ndef makeVideo():\n    out = cv2.VideoWriter(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".mp4\",\n        cv2.VideoWriter_fourcc(*\"mp4v\"),\n        16,\n        (800, 500),\n    )\n    for count in tqdm(range(1, 500 + 1)):\n        fileName = \"Image_sort/\" + str(args.f) + \"/\" + str(count) + \".jpg\"\n        img = cv2.imread(fileName)\n        out.write(img)\n        os.remove(fileName)\n    out.release()\n\n\ndef main():\n    global img_list\n    img = cv2.imread(\"Image/\" + str(args.f) + \".jpg\")\n    img = cv2.resize(img, (800, 500))\n    img_list.append(img)\n\n    height, width, _ = img.shape\n    print(\">>> Row-wise Color sorting\")\n    for row in tqdm(range(0, height)):\n        color, color_n = [], []\n        add = []\n\n        for col in range(0, width):\n            val = img[row][col].tolist()\n\n            # val includes all rgb values between the range of 0 to 1\n            # This makes the sorting easier and efficient\n            val = [i / 255.0 for i in val]\n            color.append(val)\n\n        thresh = findThreshold(\n            color, add\n        )  # setting the threshold value for every row in the frame\n\n        # For the specific row , if all the values are non-zero then it is sorted with color\n        if np.all(np.asarray(color)) == True:\n            color.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color, img, row)\n            measure(len(color), row, col, height, width)\n\n        # For the specific row , if any of the values are zero it gets sorted with color_n\n        if np.all(np.asarray(color)) == False:\n            for ind, i in enumerate(color):\n                # Accessing every list within color\n                # Added to color_n if any of the element in the list is non-zero\n                # and their sum is less than threshold  value\n\n                if np.any(np.asarray(i)) == True and sum(i) < thresh:\n                    color_n.append(i)\n\n            color_n.sort(key=lambda bgr: step(bgr, 8))  # step sorting\n            band, img = generateColors(color_n, img, row)\n            measure(len(color_n), row, col, height, width)\n        cv2.imwrite(\"Image_sort/\" + str(args.f) + \"/\" + str(row + 1) + \".jpg\", img)\n\n    # Writing down the final sorted image\n    cv2.imwrite(\n        \"Image_sort/\" + str(args.f) + \"/\" + str(args.f) + \".jpg\", img\n    )  # Displaying the final picture\n\n    print(\"\\n>>> Formation of the Video progress of the pixel-sorted image\")\n    makeVideo()\n    sound.main(\n        args.f\n    )  # Calling the external python file to create the audio of the pixel-sorted image\n\n\nmain()\n"
    },
    {
        "id": 4,
        "filename": "5.txt",
        "prefix": "\nimport os\nimport random\nfrom functools import namedtuple\n\n\"\"\"\nTarget: BlackJack 21 simulate\n    - Role\n        - Dealer: 1\n            - Insurance: (When dealer Get A(1) face up)\n                - When dealer got 21\n                    - lost chips\n                - When dealer doesn't got 21\n                    - win double chips (Your Insurance)\n        - Player: 1\n            - Bet: (Drop chip before gambling start)\n            - Hit: (Take other card from the dealer)\n            - Stand: (No more card dealer may take card when rank under 17)\n            - Double down: (When you got over 10 in first hand)\n                           (Get one card)\n            - Surrender: (only available as first decision of a hand)\n                - Dealer return 50% chips\n\"\"\"\n\n__author__ = \"Alopex Cheung\"\n__version__ = \"0.2\"\n\nBLACK_JACK = 21\nBASE_VALUE = 17\n\nCOLOR = {\n    \"PURPLE\": \"\\033[1;35;48m\",\n    \"CYAN\": \"\\033[1;36;48m\",\n    \"BOLD\": \"\\033[1;37;48m\",\n    \"BLUE\": \"\\033[1;34;48m\",\n    \"GREEN\": \"\\033[1;32;48m\",\n    \"YELLOW\": \"\\033[1;33;48m\",\n    \"RED\": \"\\033[1;31;48m\",\n    \"BLACK\": \"\\033[1;30;48m\",\n    \"UNDERLINE\": \"\\033[4;37;48m\",\n    \"END\": \"\\033[1;37;0m\",\n}\n\n\nclass Card:\n    __slots__ = \"suit\", \"rank\", \"is_face\"\n\n    def __init__(self, suit, rank, face=True):\n        \"\"\"\n        :param suit: patter in the card\n        :param rank: point in the card\n        :param face: show or cover the face(point & pattern on it)\n        \"\"\"\n        self.suit = suit\n        self.rank = rank\n        self.is_face = face\n\n    def __repr__(self):\n        fmt_card = \"\\t<rank: {rank:2}, suit: {suit:8}>\"\n        if self.is_face:\n            return fmt_card.format(suit=self.suit, rank=self.rank)\n        return fmt_card.format(suit=\"*-Back-*\", rank=\"*-Back-*\")\n\n    def show(self):\n        print(str(self))\n\n\nclass Deck:\n    def __init__(self, num=1):\n        \"\"\"\n        :param num: the number of deck\n        \"\"\"\n        self.num = num\n        self.cards = []\n        self.built()\n\n    def __repr__(self):\n        return \"\\n\".join([str(card) for card in self.cards])\n\n    def __len__(self):\n        return len(self.cards)\n\n    def built(self):\n        for _ in range(self.num):\n            ranks = [x for x in range(1, 14)]\n            suits = \"Spades Heart Clubs Diamonds\".split()\n            for suit in suits:\n                for rank in ranks:\n                    card = Card(suit, rank)\n                    self.cards.append(card)\n\n    def shuffle(self):\n        for _ in range(self.num):\n            for index in range(len(self.cards)):\n                i = random.randint(0, 51)\n                self.cards[index], self.cards[i] = self.cards[i], self.cards[index]\n\n    def rebuilt(self):\n        self.cards.clear()\n        self.built()\n\n    def deliver(self):\n        return self.cards.pop()\n\n\nclass Chips:\n    def __init__(self, amount):\n        \"\"\"\n        :param amount: the chips you own\n        \"\"\"\n        self._amount = amount\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_insurance = False\n        self.is_double = False\n\n    def __bool__(self):\n        return self.amount > 0\n\n    @staticmethod\n    def get_tips(content):\n        fmt_tips = \"{color}** TIPS: {content}! **{end}\"\n        return fmt_tips.format(\n            color=COLOR.get(\"YELLOW\"), content=content, end=COLOR.get(\"END\")\n        )\n\n    @property\n    def amount(self):\n        return self._amount\n\n    @amount.setter\n    def amount(self, value):\n        if not isinstance(value, int):\n            type_tips = \"Please give a integer\"\n            raise ValueError(Chips.get_tips(type_tips))\n        if value < 0:\n            amount_tips = \"Your integer should bigger than 0\"\n            raise ValueError(Chips.get_tips(amount_tips))\n        self._amount = value\n\n    @property\n    def bet_amount(self):\n        return self._bet_amount\n\n    @bet_amount.setter\n    def bet_amount(self, value):\n        type_tips = \"Please give a integer\"\n        amount_tips = \"Your chips should between 1 - \" + str(self.amount) + \" \"\n        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(Chips.get_tips(type_tips))\n        else:\n            if not isinstance(value, int):\n                raise ValueError(Chips.get_tips(type_tips))\n            if (value <= 0) or (value > self.amount):\n                raise ValueError(Chips.get_tips(amount_tips))\n            self._bet_amount = value\n\n    def double_bet(self):\n        if self.can_double():\n            self._bet_amount *= 2\n            self.is_double = True\n        else:\n            over_tips = \"Not enough chips || \"\n            cannot_double = \"CAN'T DO DOUBLE\"\n            raise ValueError(Chips.get_tips(over_tips + cannot_double))\n\n    @property\n    def insurance(self):\n        return self._insurance\n\n    @insurance.setter\n    def insurance(self, value):\n        if self.amount - value < 0:\n            over_tips = \"Not enough chips\"\n            raise ValueError(Chips.get_tips(over_tips))\n        self._insurance = value\n        self.is_insurance = True\n\n    def current_amount(self):\n        return self.amount - self.bet_amount - self.insurance\n\n    def reset_chip(self):\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_double = False\n        self.is_insurance = False\n\n    def can_double(self):\n        return self.current_amount() - self.bet_amount >= 0\n\n\nclass User:\n    def __init__(self, name, role, chips_amount=None, color=\"END\"):\n        \"\"\"\n        :param name: User name\n        :param role: dealer or player\n        :param chips_amount: Casino tokens equal money\n        \"\"\"\n        self.name = name\n        self.prompt = \"{role} >> ({name}) : \".format(role=role, name=self.name)\n        self.chips = Chips(chips_amount)\n        self.color = color\n        self.hand = []\n        self.point = 0\n\n    def __repr__(self):\n        return str(self.__dict__)\n\n    def obtain_card(self, deck, face=True):\n        card = deck.deliver()\n        card.is_face = face\n        self.hand.append(card)\n\n    def drop_card(self):\n        self.hand.clear()\n        self.point = 0\n\n    def show_card(self):\n        print(\"\\t    ** Here is my card **\")\n        for card in self.hand:\n            card.show()\n\n    def unveil_card(self):\n        for card in self.hand:\n            card.is_face = True\n        self.show_card()\n\n    def calculate_point(self):\n        def _extract_rank():\n            raw_ranks = [card.rank for card in self.hand]\n            cook_ranks = [10 if rank > 10 else rank for rank in raw_ranks]\n            return cook_ranks\n\n        def _sum_up(ranks):\n            rank_one = sum(ranks)\n            rank_eleven = sum([11 if rank == 1 else rank for rank in ranks])\n            # Over or has 2 Ace\n            if (ranks[::-1] == ranks) and (1 in ranks):\n                return 11 + len(ranks) - 1\n            if rank_eleven <= BLACK_JACK:\n                return rank_eleven\n            return rank_one\n\n        points = _extract_rank()\n        self.point = _sum_up(points)\n\n    def is_point(self, opt, point):\n        self.calculate_point()\n        compare_fmt = \"{user_point} {opt} {point}\".format(\n            user_point=self.point, opt=opt, point=point\n        )\n        return eval(compare_fmt)\n\n    def speak(self, content=\"\", end_char=\"\\n\"):\n        print(\"\")\n        print(\n            COLOR.get(self.color) + self.prompt + COLOR.get(\"END\") + content,\n            end=end_char,\n        )\n\n    def showing(self):\n        self.speak()\n        self.show_card()\n\n    def unveiling(self):\n        self.calculate_point()\n        points_fmt = \"My point is: {}\".format(str(self.point))\n        self.speak(points_fmt)\n        self.unveil_card()\n\n\nclass Dealer(User):\n    def __init__(self, name):\n        super().__init__(name=name, role=\"Dealer\", color=\"PURPLE\")\n        self.trigger = 0\n\n    def ask_insurance(self):\n        buy_insurance = (\n            \"(Insurance pay 2 to 1)\\n\"\n            \"\\tMy Face card is an Ace.\\n\"\n            \"\\tWould your like buy a insurance ?\"\n        )\n        self.speak(content=buy_insurance)\n\n    def strategy_trigger(self, deck):\n        if self.is_point(\"<\", BASE_VALUE):\n            self.obtain_card(deck)\n        else:\n            self.trigger += random.randint(0, 5)\n            if self.trigger % 5 == 0:\n                self.obtain_card(deck)\n\n\nclass Player(User):\n    def __init__(self, name, amount):\n        super().__init__(name=name, chips_amount=amount, role=\"Player\", color=\"CYAN\")\n        self.refresh_prompt()\n\n    def refresh_prompt(self):\n        self.prompt = \"{role} [ ${remain} ] >> ({name}) : \".format(\n            role=\"Player\", name=self.name, remain=self.chips.current_amount()\n        )\n\n    def select_choice(self, pattern):\n        my_turn = \"My turn now.\"\n        self.speak(content=my_turn)\n        operation = {\n            \"I\": \"Insurance\",\n            \"H\": \"Hit\",\n            \"S\": \"Stand\",\n            \"D\": \"Double-down\",\n            \"U\": \"Surrender\",\n        }\n        enu_choice = enumerate((operation.get(p) for p in pattern), 1)\n        dict_choice = dict(enu_choice)\n        for index, operator in dict_choice.items():\n            choice_fmt = \"\\t[{index}] {operation}\"\n            print(choice_fmt.format(index=index, operation=operator))\n        return dict_choice\n\n\nclass Recorder:\n    def __init__(self):\n        self.data = []\n        self.winner = None\n        self.remain_chips = 0\n        self.rounds = 0\n        self.player_win_count = 0\n        self.dealer_win_count = 0\n        self.player_point = 0\n        self.dealer_point = 0\n\n    def update(self, winner, chips, player_point, dealer_point):\n        self.rounds += 1\n        self.remain_chips = chips\n        self.winner = winner\n        if self.winner == \"Player\":\n            self.player_win_count += 1\n        elif self.winner == \"Dealer\":\n            self.dealer_win_count += 1\n        self.player_point = player_point\n        self.dealer_point = dealer_point\n\n    def record(self, winner, chips, player_point, dealer_point):\n        self.update(winner, chips, player_point, dealer_point)\n        Row = namedtuple(\n            \"Row\", [\"rounds\", \"player_point\", \"dealer_point\", \"winner\", \"remain_chips\"]\n        )\n        row = Row(\n            self.rounds,\n            self.player_point,\n            self.dealer_point,\n            self.winner,\n            self.remain_chips,\n        )\n        self.data.append(row)\n\n    def draw_diagram(self):\n        content = \"Record display\"\n        bars = \"--\" * 14\n        content_bar = bars + content + bars\n        base_bar = bars + \"-\" * len(content) + bars\n\n        os.system(\"clear\")\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n        self.digram()\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n\n    def digram(self):\n        title = \"Round\\tPlayer-Point\\tDealer-Point\\tWinner-is\\tRemain-Chips\"\n        row_fmt = \"{}\\t{}\\t\\t{}\\t\\t{}\\t\\t{}\"\n\n        print(title)\n        for row in self.data:\n            print(\n                row_fmt.format(\n                    row.rounds,\n                    row.player_point,\n                    row.dealer_point,\n                    row.winner,\n                    row.remain_chips,\n                )\n            )\n\n        print(\"\")\n        win_rate_fmt = \">> Player win rate: {}%\\n>> Dealer win rate: {}%\"\n        try:\n            player_rate = round(self.player_win_count / self.rounds * 100, 2)\n            dealer_rate = round(self.dealer_win_count / self.rounds * 100, 2)\n        except ZeroDivisionError:\n            player_rate = 0\n            dealer_rate = 0\n        print(win_rate_fmt.format(player_rate, dealer_rate))\n\n\nclass BlackJack:\n    def __init__(self, username):\n        self.deck = Deck()\n        self.dealer = Dealer(\"Bob\")\n        self.player = Player(username.title(), 1000)\n        self.recorder = Recorder()\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.res = None\n\n    def play(self):\n        while self.player.chips:\n            self.initial_game()\n            self.in_bet()\n            self.deal_card()\n            while self.go_on:\n                self.choice = self.menu()\n                # self.player.speak()\n                self.chips_manage()\n                try:\n                    self.card_manage()\n                except ValueError as res:\n                    self.bust = True\n                    self.go_on = False\n                    self.res = res\n            if not self.bust:\n                self.is_surrender()\n            self.winner = self.get_winner()\n            self.res = \"Winner is \" + self.winner\n            os.system(\"clear\")\n            self.calculate_chips()\n            self.result_exhibit()\n            self.dealer.unveiling()\n            self.player.unveiling()\n            self.recorder.record(\n                self.winner,\n                self.player.chips.amount,\n                self.player.point,\n                self.dealer.point,\n            )\n\n        self.recorder.draw_diagram()\n        ending = \"\\n\\tSorry I lost all chips!\\n\\tTime to say goodbye.\"\n        self.player.speak(ending)\n        print(\"\\n\" + \"-\" * 20 + \" End Game \" + \"-\" * 20)\n\n    def initial_game(self):\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.deck.rebuilt()\n        self.deck.shuffle()\n        self.player.chips.reset_chip()\n        self.player.drop_card()\n        self.player.refresh_prompt()\n        self.dealer.drop_card()\n        print(\"\\n\" + \"-\" * 20 + \" Start Game \" + \"-\" * 20)\n\n    def in_bet(self):\n        in_bet = \"\\n\\tI want to bet: \"\n        not_invalid = True\n        self.player.speak(in_bet, end_char=\"\")\n        while not_invalid:\n            try:\n                self.player.chips.bet_amount = input()\n            except ValueError as e:\n                print(e)\n                self.player.speak(in_bet, end_char=\"\")\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                self.recorder.draw_diagram()\n                quit()\n            else:\n                self.player.refresh_prompt()\n                # self.player.speak()\n                not_invalid = False\n\n    def deal_card(self):\n        # dealer\n        self.dealer.obtain_card(self.deck, face=False)\n        self.dealer.obtain_card(self.deck)\n\n        # player\n        self.player.obtain_card(self.deck)\n        self.player.obtain_card(self.deck)\n\n        self.dealer.showing()\n        self.player.showing()\n\n    def menu(self):\n        pattern = \"HS\"\n        if self.first_hand:\n            pattern += \"U\"\n            if self.dealer.hand[1].rank == 1 and self.player.chips.current_amount():\n                pattern += \"I\"\n                self.dealer.ask_insurance()\n            if self.player.is_point(\">\", 10) and self.player.chips.can_double():\n                pattern += \"D\"\n            self.first_hand = False\n        choices =",
        "middle": " self.player.select_choice",
        "suffix": "(pattern)\n        select = self.get_select(len(choices), general_err=\"Select above number.\")\n        return choices[select]\n\n    @staticmethod\n    def get_select(select_max, prompt=\">> \", general_err=\"\"):\n        while True:\n            try:\n                value = input(prompt)\n                select = int(value)\n                if select > select_max:\n                    raise ValueError\n            except ValueError:\n                print(general_err)\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                quit()\n            else:\n                return select\n\n    def chips_manage(self):\n        if self.choice == \"Insurance\":\n            err = \"The amount should under \" + str(self.player.chips.current_amount())\n            pay_ins = self.get_select(\n                self.player.chips.current_amount(),\n                prompt=\"Insurance amount >> \",\n                general_err=err,\n            )\n            self.player.chips.insurance = pay_ins\n\n        if self.choice == \"Double-down\":\n            try:\n                self.player.chips.double_bet()\n            except ValueError as e:\n                print(e)\n        self.player.refresh_prompt()\n        if self.choice in (\"Insurance\", \"Double-down\", \"Surrender\"):\n            self.go_on = False\n\n    def card_manage(self):\n        if self.choice in (\"Hit\", \"Double-down\"):\n            self.player.obtain_card(self.deck)\n            if self.player.is_point(\">\", BLACK_JACK):\n                raise ValueError(\"Player BUST\")\n            else:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n        elif self.choice != \"Surrender\":\n            if not self.player.chips.is_insurance:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n\n        self.dealer.showing()\n        self.player.showing()\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.go_on = False\n\n    def is_surrender(self):\n        if self.choice == \"Surrender\":\n            self.player.speak(\"Sorry, I surrender....\\n\")\n\n    def get_winner(self):\n        if self.bust:\n            return \"Dealer\" if self.player.is_point(\">\", BLACK_JACK) else \"Player\"\n\n        if self.choice == \"Surrender\":\n            return \"Dealer\"\n        elif self.choice == \"Insurance\":\n            if self.player.is_point(\"==\", BLACK_JACK):\n                return \"Dealer\"\n            return \"Player\"\n\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.player.calculate_point()\n            self.dealer.calculate_point()\n            if self.player.point > self.dealer.point:\n                return \"Player\"\n            return \"Dealer\"\n\n        return \"Both\"\n\n    def calculate_chips(self):\n        if self.choice == \"Surrender\":\n            if self.player.chips.bet_amount == 1:\n                if self.player.chips.current_amount() == 0:\n                    self.player.chips.amount = 0\n            else:\n                surrender_amount = self.player.chips.bet_amount // 2\n                self.player.chips.amount -= surrender_amount\n\n        elif self.choice in (\"Double-down\", \"Stand\", \"Insurance\", \"Hit\"):\n            if self.winner == \"Player\":\n                self.player.chips.amount += (\n                    self.player.chips.bet_amount + self.player.chips.insurance * 2\n                )\n            elif self.winner == \"Dealer\":\n                self.player.chips.amount -= (\n                    self.player.chips.bet_amount + self.player.chips.insurance\n                )\n\n    def result_exhibit(self):\n        def get_color():\n            if \"BUST\" in content:\n                return COLOR.get(\"RED\" if \"Player\" in content else \"GREEN\")\n            if self.winner == \"Player\":\n                return COLOR.get(\"GREEN\")\n            elif self.winner == \"Dealer\":\n                return COLOR.get(\"RED\")\n            else:\n                return COLOR.get(\"YELLOW\")\n\n        end = COLOR.get(\"END\")\n        content = str(self.res)\n        color = get_color()\n        winner_fmt = color + \"\\n\\t>> {content} <<\\n\" + end\n        print(winner_fmt.format(content=content))\n\n\ndef main():\n    try:\n        user_name = input(\"What is your name: \")\n    except KeyboardInterrupt:\n        print(\"\")\n    else:\n        black_jack = BlackJack(username=user_name)\n        black_jack.play()\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
        "id": 5,
        "filename": "5.txt",
        "prefix": "\nimport os\nimport random\nfrom functools import namedtuple\n\n\"\"\"\nTarget: BlackJack 21 simulate\n    - Role\n        - Dealer: 1\n            - Insurance: (When dealer Get A(1) face up)\n                - When dealer got 21\n                    - lost chips\n                - When dealer doesn't got 21\n                    - win double chips (Your Insurance)\n        - Player: 1\n            - Bet: (Drop chip before gambling start)\n            - Hit: (Take other card from the dealer)\n            - Stand: (No more card dealer may take card when rank under 17)\n            - Double down: (When you got over 10 in first hand)\n                           (Get one card)\n            - Surrender: (only available as first decision of a hand)\n                - Dealer return 50% chips\n\"\"\"\n\n__author__ = \"Alopex Cheung\"\n__version__ = \"0.2\"\n\nBLACK_JACK = 21\nBASE_VALUE = 17\n\nCOLOR = {\n    \"PURPLE\": \"\\033[1;35;48m\",\n    \"CYAN\": \"\\033[1;36;48m\",\n    \"BOLD\": \"\\033[1;37;48m\",\n    \"BLUE\": \"\\033[1;34;48m\",\n    \"GREEN\": \"\\033[1;32;48m\",\n    \"YELLOW\": \"\\033[1;33;48m\",\n    \"RED\": \"\\033[1;31;48m\",\n    \"BLACK\": \"\\033[1;30;48m\",\n    \"UNDERLINE\": \"\\033[4;37;48m\",\n    \"END\": \"\\033[1;37;0m\",\n}\n\n\nclass Card:\n    __slots__ = \"suit\", \"rank\", \"is_face\"\n\n    def __init__(self, suit, rank, face=True):\n        \"\"\"\n        :param suit: patter in the card\n        :param rank: point in the card\n        :param face: show or cover the face(point & pattern on it)\n        \"\"\"\n        self.suit = suit\n        self.rank = rank\n        self.is_face = face\n\n    def __repr__(self):\n        fmt_card = \"\\t<rank: {rank:2}, suit: {suit:8}>\"\n        if self.is_face:\n            return fmt_card.format(suit=self.suit, rank=self.rank)\n        return fmt_card.format(suit=\"*-Back-*\", rank=\"*-Back-*\")\n\n    def show(self):\n        print(str(self))\n\n\nclass Deck:\n    def __init__(self, num=1):\n        \"\"\"\n        :param num: the number of deck\n        \"\"\"\n        self.num = num\n        self.cards = []\n        self.built()\n\n    def __repr__(self):\n        return \"\\n\".join([str(card) for card in self.cards])\n\n    def __len__(self):\n        return len(self.cards)\n\n    def built(self):\n        for _ in range(self.num):\n            ranks = [x for x in range(1, 14)]\n            suits = \"Spades Heart Clubs Diamonds\".split()\n            for suit in suits:\n                for rank in ranks:\n                    card = Card(suit, rank)\n                    self.cards.append(card)\n\n    def shuffle(self):\n        for _ in range(self.num):\n            for index in range(len(self.cards)):\n                i = random.randint(0, 51)\n                self.cards[index], self.cards[i] = self.cards[i], self.cards[index]\n\n    def rebuilt(self):\n        self.cards.clear()\n        self.built()\n\n    def deliver(self):\n        return self.cards.pop()\n\n\nclass Chips:\n    def __init__(self, amount):\n        \"\"\"\n        :param amount: the chips you own\n        \"\"\"\n        self._amount = amount\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_insurance = False\n        self.is_double = False\n\n    def __bool__(self):\n        return self.amount > 0\n\n    @staticmethod\n    def get_tips(content):\n        fmt_tips = \"{color}** TIPS: {content}! **{end}\"\n        return fmt_tips.format(\n            color=COLOR.get(\"YELLOW\"), content=content, end=COLOR.get(\"END\")\n        )\n\n    @property\n    def amount(self):\n        return self._amount\n\n    @amount.setter\n    def amount(self, value):\n        if not isinstance(value, int):\n            type_tips = \"Please give a integer\"\n            raise ValueError(Chips.get_tips(type_tips))\n        if value < 0:\n            amount_tips = \"Your integer should bigger than 0\"\n            raise ValueError(Chips.get_tips(amount_tips))\n        self._amount = value\n\n    @property\n    def bet_amount(self):\n        return self._bet_amount\n\n    @bet_amount.setter\n    def bet_amount(self, value):\n        type_tips = \"Please give a integer\"\n        amount_tips = \"Your chips should between 1 - \" + str(self.amount) + \" \"\n        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(Chips.get_tips(type_tips))\n        else:\n            if not isinstance(value, int):\n                raise ValueError(Chips.get_tips(type_tips))\n            if (value <= 0) or (value > self.amount):\n                raise ValueError(Chips.get_tips(amount_tips))\n            self._bet_amount = value\n\n    def double_bet(self):\n        if self.can_double():\n            self._bet_amount *= 2\n            self.is_double = True\n        else:\n            over_tips = \"Not enough chips || \"\n            cannot_double = \"CAN'T DO DOUBLE\"\n            raise ValueError(Chips.get_tips(over_tips + cannot_double))\n\n    @property\n    def insurance(self):\n        return self._insurance\n\n    @insurance.setter\n    def insurance(self, value):\n        if self.amount - value < 0:\n            over_tips = \"Not enough chips\"\n            raise ValueError(Chips.get_tips(over_tips))\n        self._insurance = value\n        self.is_insurance = True\n\n    def current_amount(self):\n        return self.amount - self.bet_amount - self.insurance\n\n    def reset_chip(self):\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_double = False\n        self.is_insurance = False\n\n    def can_double(self):\n        return self.current_amount() - self.bet_amount >= 0\n\n\nclass User:\n    def __init__(self, name, role, chips_amount=None, color=\"END\"):\n        \"\"\"\n        :param name: User name\n        :param role: dealer or player\n        :param chips_amount: Casino tokens equal money\n        \"\"\"\n        self.name = name\n        self.prompt = \"{role} >> ({name}) : \".format(role=role, name=self.name)\n        self.chips = Chips(chips_amount)\n        self.color = color\n        self.hand = []\n        self.point = 0\n\n    def __repr__(self):\n        return str(self.__dict__)\n\n    def obtain_card(self, deck, face=True):\n        card = deck.deliver()\n        card.is_face = face\n        self.hand.append(card)\n\n    def drop_card(self):\n        self.hand.clear()\n        self.point = 0\n\n    def show_card(self):\n        print(\"\\t    ** Here is my card **\")\n        for card in self.hand:\n            card.show()\n\n    def unveil_card(self):\n        for card in self.hand:\n            card.is_face = True\n        self.show_card()\n\n    def calculate_point(self):\n        def _extract_rank():\n            raw_ranks = [card.rank for card in self.hand]\n            cook_ranks = [10 if rank > 10 else rank for rank in raw_ranks]\n            return cook_ranks\n\n        def _sum_up(ranks):\n            rank_one = sum(ranks)\n            rank_eleven = sum([11 if rank == 1 else rank for rank in ranks])\n            # Over or has 2 Ace\n            if (ranks[::-1] == ranks) and (1 in ranks):\n                return 11 + len(ranks) - 1\n            if rank_eleven <= BLACK_JACK:\n                return rank_eleven\n            return rank_one\n\n        points = _extract_rank()\n        self.point = _sum_up(points)\n\n    def is_point(self, opt, point):\n        self.calculate_point()\n        compare_fmt = \"{user_point} {opt} {point}\".format(\n            user_point=self.point, opt=opt, point=point\n        )\n        return eval(compare_fmt)\n\n    def speak(self, content=\"\", end_char=\"\\n\"):\n        print(\"\")\n        print(\n            COLOR.get(self.color) + self.prompt + COLOR.get(\"END\") + content,\n            end=end_char,\n        )\n\n    def showing(self):\n        self.speak()\n        self.show_card()\n\n    def unveiling(self):\n        self.calculate_point()\n        points_fmt = \"My point is: {}\".format(str(self.point))\n        self.speak(points_fmt)\n        self.unveil_card()\n\n\nclass Dealer(User):\n    def __init__(self, name):\n        super().__init__(name=name, role=\"Dealer\", color=\"PURPLE\")\n        self.trigger = 0\n\n    def ask_insurance(self):\n        buy_insurance = (\n            \"(Insurance pay 2 to 1)\\n\"\n            \"\\tMy Face card is an Ace.\\n\"\n            \"\\tWould your like buy a insurance ?\"\n        )\n        self.speak(content=buy_insurance)\n\n    def strategy_trigger(self, deck):\n        if self.is_point(\"<\", BASE_VALUE):\n            self.obtain_card(deck)\n        else:\n            self.trigger += random.randint(0, 5)\n            if self.trigger % 5 == 0:\n                self.obtain_card(deck)\n\n\nclass Player(User):\n    def __init__(self, name, amount):\n        super().__init__(name=name, chips_amount=amount, role=\"Player\", color=\"CYAN\")\n        self.refresh_prompt()\n\n    def refresh_prompt(self):\n        self.prompt = \"{role} [ ${remain} ] >> ({name}) : \".format(\n            role=\"Player\", name=self.name, remain=self.chips.current_amount()\n        )\n\n    def select_choice(self, pattern):\n        my_turn = \"My turn now.\"\n        self.speak(content=my_turn)\n        operation = {\n            \"I\": \"Insurance\",\n            \"H\": \"Hit\",\n            \"S\": \"Stand\",\n            \"D\": \"Double-down\",\n            \"U\": \"Surrender\",\n        }\n        enu_choice = enumerate((operation.get(p) for p in pattern), 1)\n        dict_choice = dict(enu_choice)\n        for index, operator in dict_choice.items():\n            choice_fmt = \"\\t[{index}] {operation}\"\n            print(choice_fmt.format(index=index, operation=operator))\n        return dict_choice\n\n\nclass Recorder:\n    def __init__(self):\n        self.data = []\n        self.winner = None\n        self.remain_chips = 0\n        self.rounds = 0\n        self.player_win_count = 0\n        self.dealer_win_count = 0\n        self.player_point = 0\n        self.dealer_point = 0\n\n    def update(self, winner, chips, player_point, dealer_point):\n        self.rounds += 1\n        self.remain_chips = chips\n        self.winner = winner\n        if self.winner == \"Player\":\n            self.player_win_count += 1\n        elif self.winner == \"Dealer\":\n            self.dealer_win_count += 1\n        self.player_point = player_point\n        self.dealer_point = dealer_point\n\n    def record(self, winner, chips, player_point, dealer_point):\n        self.update(winner, chips, player_point, dealer_point)\n        Row = namedtuple(\n            \"Row\", [\"rounds\", \"player_point\", \"dealer_point\", \"winner\", \"remain_chips\"]\n        )\n        row = Row(\n            self.rounds,\n            self.player_point,\n            self.dealer_point,\n            self.winner,\n            self.remain_chips,\n        )\n        self.data.append(row)\n\n    def draw_diagram(self):\n        content = \"Record display\"\n        bars = \"--\" * 14\n        content_bar = bars + content + bars\n        base_bar = bars + \"-\" * len(content) + bars\n\n        os.system(\"clear\")\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n        self.digram()\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n\n    def digram(self):\n        title = \"Round\\tPlayer-Point\\tDealer-Point\\tWinner-is\\tRemain-Chips\"\n        row_fmt = \"{}\\t{}\\t\\t{}\\t\\t{}\\t\\t{}\"\n\n        print(title)\n        for row in self.data:\n            print(\n                row_fmt.format(\n                    row.rounds,\n                    row.player_point,\n                    row.dealer_point,\n                    row.winner,\n                    row.remain_chips,\n             ",
        "middle": "   )\n            )\n\n        print(\"\")\n        win_rate_fmt = \">> Player win rate: {}%\\n>> Dealer win rate: ",
        "suffix": "{}%\"\n        try:\n            player_rate = round(self.player_win_count / self.rounds * 100, 2)\n            dealer_rate = round(self.dealer_win_count / self.rounds * 100, 2)\n        except ZeroDivisionError:\n            player_rate = 0\n            dealer_rate = 0\n        print(win_rate_fmt.format(player_rate, dealer_rate))\n\n\nclass BlackJack:\n    def __init__(self, username):\n        self.deck = Deck()\n        self.dealer = Dealer(\"Bob\")\n        self.player = Player(username.title(), 1000)\n        self.recorder = Recorder()\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.res = None\n\n    def play(self):\n        while self.player.chips:\n            self.initial_game()\n            self.in_bet()\n            self.deal_card()\n            while self.go_on:\n                self.choice = self.menu()\n                # self.player.speak()\n                self.chips_manage()\n                try:\n                    self.card_manage()\n                except ValueError as res:\n                    self.bust = True\n                    self.go_on = False\n                    self.res = res\n            if not self.bust:\n                self.is_surrender()\n            self.winner = self.get_winner()\n            self.res = \"Winner is \" + self.winner\n            os.system(\"clear\")\n            self.calculate_chips()\n            self.result_exhibit()\n            self.dealer.unveiling()\n            self.player.unveiling()\n            self.recorder.record(\n                self.winner,\n                self.player.chips.amount,\n                self.player.point,\n                self.dealer.point,\n            )\n\n        self.recorder.draw_diagram()\n        ending = \"\\n\\tSorry I lost all chips!\\n\\tTime to say goodbye.\"\n        self.player.speak(ending)\n        print(\"\\n\" + \"-\" * 20 + \" End Game \" + \"-\" * 20)\n\n    def initial_game(self):\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.deck.rebuilt()\n        self.deck.shuffle()\n        self.player.chips.reset_chip()\n        self.player.drop_card()\n        self.player.refresh_prompt()\n        self.dealer.drop_card()\n        print(\"\\n\" + \"-\" * 20 + \" Start Game \" + \"-\" * 20)\n\n    def in_bet(self):\n        in_bet = \"\\n\\tI want to bet: \"\n        not_invalid = True\n        self.player.speak(in_bet, end_char=\"\")\n        while not_invalid:\n            try:\n                self.player.chips.bet_amount = input()\n            except ValueError as e:\n                print(e)\n                self.player.speak(in_bet, end_char=\"\")\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                self.recorder.draw_diagram()\n                quit()\n            else:\n                self.player.refresh_prompt()\n                # self.player.speak()\n                not_invalid = False\n\n    def deal_card(self):\n        # dealer\n        self.dealer.obtain_card(self.deck, face=False)\n        self.dealer.obtain_card(self.deck)\n\n        # player\n        self.player.obtain_card(self.deck)\n        self.player.obtain_card(self.deck)\n\n        self.dealer.showing()\n        self.player.showing()\n\n    def menu(self):\n        pattern = \"HS\"\n        if self.first_hand:\n            pattern += \"U\"\n            if self.dealer.hand[1].rank == 1 and self.player.chips.current_amount():\n                pattern += \"I\"\n                self.dealer.ask_insurance()\n            if self.player.is_point(\">\", 10) and self.player.chips.can_double():\n                pattern += \"D\"\n            self.first_hand = False\n        choices = self.player.select_choice(pattern)\n        select = self.get_select(len(choices), general_err=\"Select above number.\")\n        return choices[select]\n\n    @staticmethod\n    def get_select(select_max, prompt=\">> \", general_err=\"\"):\n        while True:\n            try:\n                value = input(prompt)\n                select = int(value)\n                if select > select_max:\n                    raise ValueError\n            except ValueError:\n                print(general_err)\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                quit()\n            else:\n                return select\n\n    def chips_manage(self):\n        if self.choice == \"Insurance\":\n            err = \"The amount should under \" + str(self.player.chips.current_amount())\n            pay_ins = self.get_select(\n                self.player.chips.current_amount(),\n                prompt=\"Insurance amount >> \",\n                general_err=err,\n            )\n            self.player.chips.insurance = pay_ins\n\n        if self.choice == \"Double-down\":\n            try:\n                self.player.chips.double_bet()\n            except ValueError as e:\n                print(e)\n        self.player.refresh_prompt()\n        if self.choice in (\"Insurance\", \"Double-down\", \"Surrender\"):\n            self.go_on = False\n\n    def card_manage(self):\n        if self.choice in (\"Hit\", \"Double-down\"):\n            self.player.obtain_card(self.deck)\n            if self.player.is_point(\">\", BLACK_JACK):\n                raise ValueError(\"Player BUST\")\n            else:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n        elif self.choice != \"Surrender\":\n            if not self.player.chips.is_insurance:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n\n        self.dealer.showing()\n        self.player.showing()\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.go_on = False\n\n    def is_surrender(self):\n        if self.choice == \"Surrender\":\n            self.player.speak(\"Sorry, I surrender....\\n\")\n\n    def get_winner(self):\n        if self.bust:\n            return \"Dealer\" if self.player.is_point(\">\", BLACK_JACK) else \"Player\"\n\n        if self.choice == \"Surrender\":\n            return \"Dealer\"\n        elif self.choice == \"Insurance\":\n            if self.player.is_point(\"==\", BLACK_JACK):\n                return \"Dealer\"\n            return \"Player\"\n\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.player.calculate_point()\n            self.dealer.calculate_point()\n            if self.player.point > self.dealer.point:\n                return \"Player\"\n            return \"Dealer\"\n\n        return \"Both\"\n\n    def calculate_chips(self):\n        if self.choice == \"Surrender\":\n            if self.player.chips.bet_amount == 1:\n                if self.player.chips.current_amount() == 0:\n                    self.player.chips.amount = 0\n            else:\n                surrender_amount = self.player.chips.bet_amount // 2\n                self.player.chips.amount -= surrender_amount\n\n        elif self.choice in (\"Double-down\", \"Stand\", \"Insurance\", \"Hit\"):\n            if self.winner == \"Player\":\n                self.player.chips.amount += (\n                    self.player.chips.bet_amount + self.player.chips.insurance * 2\n                )\n            elif self.winner == \"Dealer\":\n                self.player.chips.amount -= (\n                    self.player.chips.bet_amount + self.player.chips.insurance\n                )\n\n    def result_exhibit(self):\n        def get_color():\n            if \"BUST\" in content:\n                return COLOR.get(\"RED\" if \"Player\" in content else \"GREEN\")\n            if self.winner == \"Player\":\n                return COLOR.get(\"GREEN\")\n            elif self.winner == \"Dealer\":\n                return COLOR.get(\"RED\")\n            else:\n                return COLOR.get(\"YELLOW\")\n\n        end = COLOR.get(\"END\")\n        content = str(self.res)\n        color = get_color()\n        winner_fmt = color + \"\\n\\t>> {content} <<\\n\" + end\n        print(winner_fmt.format(content=content))\n\n\ndef main():\n    try:\n        user_name = input(\"What is your name: \")\n    except KeyboardInterrupt:\n        print(\"\")\n    else:\n        black_jack = BlackJack(username=user_name)\n        black_jack.play()\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
        "id": 6,
        "filename": "5.txt",
        "prefix": "\nimport os\nimport random\nfrom functools import namedtuple\n\n\"\"\"\nTarget: BlackJack 21 simulate\n    - Role\n        - Dealer: 1\n            - Insurance: (When dealer Get A(1) face up)\n                - When dealer got 21\n                    - lost chips\n                - When dealer doesn't got 21\n                    - win double chips (Your Insurance)\n        - Player: 1\n            - Bet: (Drop chip before gambling start)\n            - Hit: (Take other card from the dealer)\n            - Stand: (No more card dealer may take card when rank under 17)\n            - Double down: (When you got over 10 in first hand)\n                           (Get one card)\n            - Surrender: (only available as first decision of a hand)\n                - Dealer return 50% chips\n\"\"\"\n\n__author__ = \"Alopex Cheung\"\n__version__ = \"0.2\"\n\nBLACK_JACK = 21\nBASE_VALUE = 17\n\nCOLOR = {\n    \"PURPLE\": \"\\033[1;35;48m\",\n    \"CYAN\": \"\\033[1;36;48m\",\n    \"BOLD\": \"\\033[1;37;48m\",\n    \"BLUE\": \"\\033[1;34;48m\",\n    \"GREEN\": \"\\033[1;32;48m\",\n    \"YELLOW\": \"\\033[1;33;48m\",\n    \"RED\": \"\\033[1;31;48m\",\n    \"BLACK\": \"\\033[1;30;48m\",\n    \"UNDERLINE\": \"\\033[4;37;48m\",\n    \"END\": \"\\033[1;37;0m\",\n}\n\n\nclass Card:\n    __slots__ = \"suit\", \"rank\", \"is_face\"\n\n    def __init__(self, suit, rank, face=True):\n        \"\"\"\n        :param suit: patter in the card\n        :param rank: point in the card\n        :param face: show or cover the face(point & pattern on it)\n        \"\"\"\n        self.suit = suit\n        self.rank = rank\n        self.is_face = face\n\n    def __repr__(self):\n        fmt_card = \"\\t<rank: {rank:2}, suit: {suit:8}>\"\n        if self.is_face:\n            return fmt_card.format(suit=self.suit, rank=self.rank)\n        return fmt_card.format(suit=\"*-Back-*\", rank=\"*-Back-*\")\n\n    def show(self):\n        print(str(self))\n\n\nclass Deck:\n    def __init__(self, num=1):\n        \"\"\"\n        :param num: the number of deck\n        \"\"\"\n        self.num = num\n        self.cards = []\n        self.built()\n\n    def __repr__(self):\n        return \"\\n\".join([str(card) for card in self.cards])\n\n    def __len__(self):\n        return len(self.cards)\n\n    def built(self):\n        for _ in range(self.num):\n            ranks = [x for x in range(1, 14)]\n            suits = \"Spades Heart Clubs Diamonds\".split()\n            for suit in suits:\n                for rank in ranks:\n                    card = Card(suit, rank)\n                    self.cards.append(card)\n\n    def shuffle(self):\n        for _ in range(self.num):\n            for index in range(len(self.cards)):\n                i = random.randint(0, 51)\n                self.cards[index], self.cards[i] = self.cards[i], self.cards[index]\n\n    def rebuilt(self):\n        self.cards.clear()\n        self.built()\n\n    def deliver(self):\n        return self.cards.pop()\n\n\nclass Chips:\n    def __init__(self, amount):\n        \"\"\"\n        :param amount: the chips you own\n        \"\"\"\n        self._amount = amount\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_insurance = False\n        self.is_double = False\n\n    def __bool__(self):\n        return self.amount > 0\n\n    @staticmethod\n    def get_tips(content):\n        fmt_tips = \"{color}** TIPS: {content}! **{end}\"\n        return fmt_tips.format(\n            color=COLOR.get(\"YELLOW\"), content=content, end=COLOR.get(\"END\")\n        )\n\n    @property\n    def amount(self):\n        return self._amount\n\n    @amount.setter\n    def amount(self, value):\n        if not isinstance(value, int):\n            type_tips = \"Please give a integer\"\n            raise ValueError(Chips.get_tips(type_tips))\n        if value < 0:\n            amount_tips = \"Your integer should bigger than 0\"\n            raise ValueError(Chips.get_tips(amount_tips))\n        self._amount = value\n\n    @property\n    def bet_amount(self):\n        return self._bet_amount\n\n    @bet_amount.setter\n    def bet_amount(self, value):\n        type_tips = \"Please give a integer\"\n        amount_tips = \"Your chips should between 1 - \" + str(self.amount) + \" \"\n        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(Chips.get_tips(type_tips))\n        else:\n            if not isinstance(value, int):\n                raise ValueError(Chips.get_tips(type_tips))\n            if (value <= 0) or (value > self.amount):\n                raise ValueError(Chips.get_tips(amount_tips))\n            self._bet_amount = value\n\n    def double_bet(self):\n        if self.can_double():\n            self._bet_amount *= 2\n            self.is_double = True\n        else:\n            over_tips = \"Not enough chips || \"\n            cannot_double = \"CAN'T DO DOUBLE\"\n            raise ValueError(Chips.get_tips(over_tips + cannot_double))\n\n    @property\n    def insurance(self):\n        return self._insurance\n\n    @insurance.setter\n    def insurance(self, value):\n        if self.amount - value < 0:\n            over_tips = \"Not enough chips\"\n            raise ValueError(Chips.get_tips(over_tips))\n        self._insurance = value\n        self.is_insurance = True\n\n    def current_amount(self):\n        return self.amount - self.bet_amount - self.insurance\n\n    def reset_chip(self):\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_double = False\n        self.is_insurance = False\n\n    def can_double(self):\n        return self.current_amount() - self.bet_amount >= 0\n\n\nclass User:\n    def __init__(self, name, role, chips_amount=None, color=\"END\"):\n        \"\"\"\n        :param name: User name\n        :param role: dealer or player\n        :param chips_amount: Casino tokens equal money\n        \"\"\"\n        self.name = name\n        self.prompt = \"{role} >> ({name}) : \".format(role=role, name=self.name)\n        self.chips = Chips(chips_amount)\n        self.color = color\n        self.hand = []\n        self.point = 0\n\n    def __repr__(self):\n        return str(self.__dict__)\n\n    def obtain_card(self, deck, face=True):\n        card = deck.deliver()\n        card.is_face = face\n        self.hand.append(card)\n\n    def drop_card(self):\n        self.hand.clear()\n        self.point = 0\n\n    def show_card(self):\n        print(\"\\t    ** Here is my card **\")\n        for card in self.hand:\n            card.show()\n\n    def unveil_card(self):\n        for card in self.hand:\n            card.is_face = True\n        self.show_card()\n\n    def calculate_point(self):\n        def _extract_rank():\n            raw_ranks = [card.rank for card in self.hand]\n            cook_ranks = [10 if rank > 10 else rank for rank in raw_ranks]\n            return cook_ranks\n\n        def _sum_up(ranks):\n            rank_one = sum(ranks)\n            rank_eleven = sum([11 if rank == 1 else rank for rank in ranks])\n            # Over or has 2 Ace\n            if (ranks[::-1] == ranks) and (1 in ranks):\n                return 11 + len(ranks) - 1\n            if rank_eleven <= BLACK_JACK:\n                return rank_eleven\n            return rank_one\n\n        points = _extract_rank()\n        self.point = _sum_up(points)\n\n    def is_point(self, opt, point):\n        self.calculate_point()\n        compare_fmt = \"{user_point} {opt} {point}\".format(\n            user_point=self.point, opt=opt, point=point\n        )\n        return eval(compare_fmt)\n\n    def speak(self, content=\"\", end_char=\"\\n\"):\n        print(\"\")\n        print(\n            COLOR.get(self.color) + self.prompt + COLOR.get(\"END\") + content,\n            end=end_char,\n        )\n\n    def showing(self):\n        self.speak()\n        self.show_card()\n\n    def unveiling(self):\n        self.calculate_point()\n        points_fmt = \"My point is: {}\".format(str(self.point))\n        self.speak(points_fmt)\n        self.unveil_card()\n\n\nclass Dealer(User):\n    def __init__(self, name):\n        super().__init__(name=name, role=\"Dealer\", color=\"PURPLE\")\n        self.trigger = 0\n\n    def ask_insurance(self):\n        buy_insurance = (\n            \"(Insurance pay 2 to 1)\\n\"\n            \"\\tMy Face card is an Ace.\\n\"\n            \"\\tWould your like buy a insurance ?\"\n        )\n        self.speak(content=buy_insurance)\n\n    def strategy_trigger(self, deck):\n        if self.is_point(\"<\", BASE_VALUE):\n            self.obtain_card(deck)\n        else:\n            self.trigger += random.randint(0, 5)\n            if self.trigger % 5 == 0:\n                self.obtain_card(deck)\n\n\nclass Player(User):\n    def __init__(self, name, amount):\n        super().__init__(name=name, chips_amount=amount, role=\"Player\", color=\"CYAN\")\n        self.refresh_prompt()\n\n    def refresh_prompt(self):\n        self.prompt = \"{role} [ ${remain} ] >> ({name}) : \".format(\n            role=\"Player\", name=self.name, remain=self.chips.current_amount()\n        )\n\n    def select_choice(self, pattern):\n        my_turn = \"My turn now.\"\n        self.speak(content=my_turn)\n        operation = {\n            \"I\": \"Insurance\",\n            \"H\": \"Hit\",\n            \"S\": \"Stand\",\n            \"D\": \"Double-down\",\n            \"U\": \"Surrender\",\n        }\n        enu_choice = enumerate((operation.get(p) for p in pattern), 1)\n        dict_choice = dict(enu_choice)\n        for index, operator in dict_choice.items():\n            choice_fmt = \"\\t[{index}] {operation}\"\n            print(choice_fmt.format(index=index, operation=operator))\n        return dict_choice\n\n\nclass Recorder:\n    def __init__(self):\n        self.data = []\n        self.winner = None\n        self.remain_chips = 0\n        self.rounds = 0\n        self.player_win_count = 0\n        self.dealer_win_count = 0\n        self.player_point = 0\n        self.dealer_point = 0\n\n    def update(self, winner, chips, player_point, dealer_point):\n        self.rounds += 1\n        self.remain_chips = chips\n        self.winner = winner\n        if self.winner == \"Player\":\n            self.player_win_count += 1\n        elif self.winner == \"Dealer\":\n            self.dealer_win_count += 1\n        self.player_point = player_point\n        self.dealer_point = dealer_point\n\n    def record(self, winner, chips, player_point, dealer_point):\n        self.update(winner, chips, player_point, dealer_point)\n        Row = namedtuple(\n            \"Row\", [\"rounds\", \"player_point\", \"dealer_point\", \"winner\", \"remain_chips\"]\n        )\n        row = Row(\n            self.rounds,\n            self.player_point,\n            self.dealer_point,\n            self.winner,\n            self.remain_chips,\n        )\n        self.data.append(row)\n\n    def draw_diagram(self):\n        content = \"Record display\"\n        bars = \"--\" * 14\n        content_bar = bars + content + bars\n        base_bar = bars + \"-\" * len(content) + bars\n\n        os.system(\"clear\")\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n        self.digram()\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n\n    def digram(self):\n        title = \"Round\\tPlayer-Point\\tDealer-Point\\tWinner-is\\tRemain-Chips\"\n        row_fmt = \"{}\\t{}\\t\\t{}\\t\\t{}\\t\\t{}\"\n\n        print(title)\n        for row in self.data:\n            print(\n                row_fmt.format(\n                    row.rounds,\n                    row.player_point,\n                    row.dealer_point,\n                    row.winner,\n                    row.remain_chips,\n                )\n            )\n\n        print(\"\")\n        win_rate_fmt = \">> Player win rate: {}%\\n>> Dealer win rate: {}%\"\n        try:\n            player_rate = round(self.player_win_count / self.rounds * 100, 2)\n            dealer_rate = round(self.dealer_win_count / self.rounds * 100, 2)\n        except ZeroDivisionError:\n            player_rate = 0\n            dealer_rate = 0\n        print(win_rate_fmt.format(player_rate, dealer_rate))\n\n\nclass BlackJack:\n    def __init__(self, username):\n        self.deck = Deck()\n        self.dealer = Dealer(\"Bob\")\n        self.player = Player(username.title(), 1000)\n        self.recorder = Recorder()\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.res = None\n\n    def play(self):\n        while self.player.chips:\n            self.initial_game()\n            self.in_bet()\n            self.deal_card()\n            while self.go_on:\n                self.choice = self.menu()\n                # self.player.speak()\n                self.chips_manage()\n                try:\n                    self.card_manage()\n                except ValueError as res:\n                    self.bust = True\n                    self.go_on = False\n                    self.res = res\n            if not self.bust:\n                self.is_surrender()\n            self.winner = self.get_winner()\n            self.res = \"Winner is \" + self.winner\n            os.system(\"clear\")\n            self.calculate_chips()\n            self.result_exhibit()\n            self.dealer.unveiling()\n            self.player.unveiling()\n            self.recorder.record(\n                self.winner,\n                self.player.chips.amount,\n                self.player.point,\n                self.dealer.point,\n            )\n\n        self.recorder.draw_diagram()\n        ending = \"\\n\\tSorry I lost all chips!\\n\\tTime to say goodbye.\"\n        self.player.speak(ending)\n        print(\"\\n\" + \"-\" * 20 + \" End Game \" + \"-\" * 20)\n\n    def initial_game(self):\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.deck.rebuilt()\n        self.deck.shuffle()\n        self.player.chips.reset_chip()\n        self.player.drop_card()\n        self.player.refresh_prompt()\n        self.dealer.drop_card()\n        print(\"\\n\" + \"-\" * 20 + \" Start Game \" + \"-\" * 20)\n\n    def in_bet(self):\n        in_bet = \"\\n\\tI want to bet: \"\n        not_invalid = True\n        self.player.speak(in_bet, end_char=\"\")\n        while not_invalid:\n            try:\n                self.player.chips.bet_amount = input()\n            except ValueError as e:\n                print(e)\n                self.player.speak(in_bet, end_char=\"\")\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                self.recorder.draw_diagram()\n                quit()\n            else:\n                self.player.refresh_prompt()\n                # self.player.speak()\n                not_invalid = False\n\n    def deal_card(self):\n        # dealer\n        self.dealer.obtain_card(self.deck, face=False)\n        self.dealer.obtain_card(self.deck)\n\n        # player\n        self.player.obtain_card(self.deck)\n        self.player.obtain_card(self.deck)\n\n        self.dealer.showing()\n        self.player.showing()\n\n    def menu(self):\n        pattern = \"HS\"\n        if self.first_hand:\n            pattern += \"U\"\n            if self.dealer.hand[1].rank == 1 and self.player.chips.current_amount():\n                pattern += \"I\"\n                self.dealer.ask_insurance()\n            if self.player.is_point(\">\", 10) and self.player.chips.can_double():\n                pattern += \"D\"\n            self.first_hand = False\n        choices = self.player.select_choice(pattern)\n        select = self.get_select(len(choices), general_err=\"Select above number.\")\n        return choices[select]\n\n    @staticmethod\n    def get_select(select_max, prompt=\">> \", general_err=\"\"):\n        while True:\n            try:\n                value = input(prompt)\n                select = int(value)\n                if select > select_max:\n                    raise ValueError\n            except ValueError:\n                print(general_err)\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                quit()\n            else:\n                return select\n\n    def chips_manage(self):\n        if self.choice == \"Insurance\":\n            err = \"The amount should under \" + str(self.player.chips.current_amount())\n            pay_ins = self.get_select(\n                self.player.chips.current_amount(),\n                prompt=\"Insurance amount >> \",\n                general_err=err,\n            )\n            self.player.chips.insurance = pay_ins\n\n        if self.choice == \"Double-down\":\n            try:\n                self.player.chips.double_bet()\n            except ValueError as e:\n                print(e)\n        self.player.refresh_prompt()\n        if self.choice in (\"Insurance\", \"Double-down\", \"Surrender\"):\n            self.go_on = False\n\n    def card_manage(self):\n        if self.choice in (\"Hit\", \"Double-down\"):\n            self.player.obtain_card(self.deck)\n            if self.player.is_point(\">\", BLACK_JACK):\n                raise ValueError(\"Player BUST\")\n            else:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n        elif self.choice != \"Surrender\":\n            if not self.player.chips.is_insurance:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n\n        self.dealer.showing()\n        self.player.showing()\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.go_on = False\n\n    def is_surrender(self):\n        if self.choice == \"Surrender\":\n            self.player.speak(\"Sorry, I surrender....\\n\")\n\n    def get_winner(self):\n        if self.bust:\n            return \"Dealer\" if self.player.is_point(\">\", BLACK_JACK) else \"Player\"\n\n        if self.choice == \"Surrender\":\n            return \"Dealer\"\n        elif self.choice == \"Insurance\":\n            if self.player.is_point(\"==\", BLACK_JACK):\n                return \"Dealer\"\n            return \"Player\"\n\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.player.calculate_point()\n            self.dealer.calculate_point()\n            if self.player.point > self.dealer.point:\n                return \"Player\"\n            return \"Dealer\"\n\n        return \"Both\"\n\n    def calculate_chips(self):\n        if self.choice == \"Surrender\":\n            if self.player.chips.bet_amount == 1:\n                if self.player.chips.current_amount() == 0:\n                    self.player.chips.amount = 0\n            else:\n                surrender_amount",
        "middle": " = self.player.chips.bet_amount",
        "suffix": " // 2\n                self.player.chips.amount -= surrender_amount\n\n        elif self.choice in (\"Double-down\", \"Stand\", \"Insurance\", \"Hit\"):\n            if self.winner == \"Player\":\n                self.player.chips.amount += (\n                    self.player.chips.bet_amount + self.player.chips.insurance * 2\n                )\n            elif self.winner == \"Dealer\":\n                self.player.chips.amount -= (\n                    self.player.chips.bet_amount + self.player.chips.insurance\n                )\n\n    def result_exhibit(self):\n        def get_color():\n            if \"BUST\" in content:\n                return COLOR.get(\"RED\" if \"Player\" in content else \"GREEN\")\n            if self.winner == \"Player\":\n                return COLOR.get(\"GREEN\")\n            elif self.winner == \"Dealer\":\n                return COLOR.get(\"RED\")\n            else:\n                return COLOR.get(\"YELLOW\")\n\n        end = COLOR.get(\"END\")\n        content = str(self.res)\n        color = get_color()\n        winner_fmt = color + \"\\n\\t>> {content} <<\\n\" + end\n        print(winner_fmt.format(content=content))\n\n\ndef main():\n    try:\n        user_name = input(\"What is your name: \")\n    except KeyboardInterrupt:\n        print(\"\")\n    else:\n        black_jack = BlackJack(username=user_name)\n        black_jack.play()\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
        "id": 7,
        "filename": "5.txt",
        "prefix": "\nimport os\nimport random\nfrom functools import namedtuple\n\n\"\"\"\nTarget: BlackJack 21 simulate\n    - Role\n        - Dealer: 1\n            - Insurance: (When dealer Get A(1) face up)\n                - When dealer got 21\n                    - lost chips\n                - When dealer doesn't got 21\n                    - win double chips (Your Insurance)\n        - Player: 1\n            - Bet: (Drop chip before gambling start)\n            - Hit: (Take other card from the dealer)\n            - Stand: (No more card dealer may take card when rank under 17)\n            - Double down: (When you got over 10 in first hand)\n                           (Get one card)\n            - Surrender: (only available as first decision of a hand)\n                - Dealer return 50% chips\n\"\"\"\n\n__author__ = \"Alopex Cheung\"\n__version__ = \"0.2\"\n\nBLACK_JACK = 21\nBASE_VALUE = 17\n\nCOLOR = {\n    \"PURPLE\": \"\\033[1;35;48m\",\n    \"CYAN\": \"\\033[1;36;48m\",\n    \"BOLD\": \"\\033[1;37;48m\",\n    \"BLUE\": \"\\033[1;34;48m\",\n    \"GREEN\": \"\\033[1;32;48m\",\n    \"YELLOW\": \"\\033[1;33;48m\",\n    \"RED\": \"\\033[1;31;48m\",\n    \"BLACK\": \"\\033[1;30;48m\",\n    \"UNDERLINE\": \"\\033[4;37;48m\",\n    \"END\": \"\\033[1;37;0m\",\n}\n\n\nclass Card:\n    __slots__ = \"suit\", \"rank\", \"is_face\"\n\n    def __init__(self, suit, rank, face=True):\n        \"\"\"\n        :param suit: patter in the card\n        :param rank: point in the card\n        :param face: show or cover the face(point & pattern on it)\n        \"\"\"\n        self.suit = suit\n        self.rank = rank\n        self.is_face = face\n\n    def __repr__(self):\n        fmt_card = \"\\t<rank: {rank:2}, suit: {suit:8}>\"\n        if self.is_face:\n            return fmt_card.format(suit=self.suit, rank=self.rank)\n        return fmt_card.format(suit=\"*-Back-*\", rank=\"*-Back-*\")\n\n    def show(self):\n        print(str(self))\n\n\nclass Deck:\n    def __init__(self, num=1):\n        \"\"\"\n        :param num: the number of deck\n        \"\"\"\n        self.num = num\n        self.cards = []\n        self.built()\n\n    def __repr__(self):\n        return \"\\n\".join([str(card) for card in self.cards])\n\n    def __len__(self):\n        return len(self.cards)\n\n    def built(self):\n        for _ in range(self.num):\n            ranks = [x for x in range(1, 14)]\n            suits = \"Spades Heart Clubs Diamonds\".split()\n            for suit in suits:\n                for rank in ranks:\n                    card = Card(suit, rank)\n                    self.cards.append(card)\n\n    def shuffle(self):\n        for _ in range(self.num):\n            for index in range(len(self.cards)):\n                i = random.randint(0, 51)\n                self.cards[index], self.cards[i] = self.cards[i], self.cards[index]\n\n    def rebuilt(self):\n        self.cards.clear()\n        self.built()\n\n    def deliver(self):\n        return self.cards.pop()\n\n\nclass Chips:\n    def __init__(self, amount):\n        \"\"\"\n        :param amount: the chips you own\n        \"\"\"\n        self._amount = amount\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_insurance = False\n        self.is_double = False\n\n    def __bool__(self):\n        return self.amount > 0\n\n    @staticmethod\n    def get_tips(content):\n        fmt_tips = \"{color}** TIPS: {content}! **{end}\"\n        return fmt_tips.format(\n            color=COLOR.get(\"YELLOW\"), content=content, end=COLOR.get(\"END\")\n        )\n\n    @property\n    def amount(self):\n        return self._amount\n\n    @amount.setter\n    def amount(self, value):\n        if not isinstance(value, int):\n            type_tips = \"Please give a integer\"\n            raise ValueError(Chips.get_tips(type_tips))\n        if value < 0:\n            amount_tips = \"Your integer should bigger than 0\"\n            raise ValueError(Chips.get_tips(amount_tips))\n        self._amount = value\n\n    @property\n    def bet_amount(self):\n        return self._bet_amount\n\n    @bet_amount.setter\n    def bet_amount(self, value):\n        type_tips = \"Please give a integer\"\n        amount_tips = \"Your chips should between 1 - \" + str(self.amount) + \" \"\n        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(Chips.get_tips(type_tips))\n        else:\n            if not isinstance(value, int):\n                raise ValueError(Chips.get_tips(type_tips))\n            if (value <= 0) or (value > self.amount):\n                raise ValueError(Chips.get_tips(amount_tips))\n            self._bet_amount = value\n\n    def double_bet(self):\n        if self.can_double():\n            self._bet_amount *= 2\n            self.is_double = True\n        else:\n            over_tips = \"Not enough chips || \"\n            cannot_double = \"CAN'T DO DOUBLE\"\n            raise ValueError(Chips.get_tips(over_tips + cannot_double))\n\n    @property\n    def insurance(self):\n        return self._insurance\n\n    @insurance.setter\n    def insurance(self, value):\n        if self.amount - value < 0:\n            over_tips = \"Not enough chips\"\n            raise ValueError(Chips.get_tips(over_tips))\n        self._insurance = value\n        self.is_insurance = True\n\n    def current_amount(self):\n        return self.amount - self.bet_amount - self.insurance\n\n    def reset_chip(self):\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_double = False\n        self.is_insurance = False\n\n    def can_double(self):\n        return self.current_amount() - self.bet_amount >= 0\n\n\nclass User:\n    def __init__(self, name, role, chips_amount=None, color=\"END\"):\n        \"\"\"\n        :param name: User name\n        :param role: dealer or player\n        :param chips_amount: Casino tokens equal money\n        \"\"\"\n        self.name = name\n        self.prompt = \"{role} >> ({name}) : \".format(role=role, name=self.name)\n        self.chips = Chips(chips_amount)\n        self.color = color\n        self.hand = []\n        self.point = 0\n\n    def __repr__(self):\n        return str(self.__dict__)\n\n    def obtain_card(self, deck, face=True):\n        card = deck.deliver()\n        card.is_face = face\n        self.hand.append(card)\n\n    def drop_card(self):\n        self.hand.clear()\n        self.point = 0\n\n    def show_card(self):\n        print(\"\\t    ** Here is my card **\")\n        for card in self.hand:\n            card.show()\n\n    def unveil_card(self):\n        for card in self.hand:\n            card.is_face = True\n        self.show_card()\n\n    def calculate_point(self):\n        def _extract_rank():\n            raw_ranks = [card.rank for card in self.hand]\n            cook_ranks = [10 if rank > 10 else rank for rank in raw_ranks]\n            return cook_ranks\n\n        def _sum_up(ranks):\n            rank_one = sum(ranks)\n            rank_eleven = sum([11 if rank == 1 else rank for rank in ranks])\n            # Over or has 2 Ace\n            if (ranks[::-1] == ranks) and (1 in ranks):\n                return 11 + len(ranks) - 1\n            if rank_eleven <= BLACK_JACK:\n                return rank_eleven\n            return rank_one\n\n        points = _extract_rank()\n        self.point = _sum_up(points)\n\n    def is_point(self, opt, point):\n        self.calculate_point()\n        compare_fmt = \"{user_point} {opt} {point}\".format(\n            user_point=self.point, opt=opt, point=point\n        )\n        return eval(compare_fmt)\n\n    def speak(self, content=\"\", end_char=\"\\n\"):\n        print(\"\")\n        print(\n            COLOR.get(self.color) + self.prompt + COLOR.get(\"END\") + content,\n            end=end_char,\n        )\n\n    def showing(self):\n        self.speak()\n        self.show_card()\n\n    def unveiling(self):\n        self.calculate_point()\n        points_fmt = \"My point is: {}\".format(str(self.point))\n        self.speak(points_fmt)\n        self.unveil_card()\n\n\nclass Dealer(User):\n    def __init__(self, name):\n        super().__init__(name=name, role=\"Dealer\", color=\"PURPLE\")\n        self.trigger = 0\n\n    def ask_insurance(self):\n        buy_insurance = (\n            \"(Insurance pay 2 to 1)\\n\"\n            \"\\tMy Face card is an Ace.\\n\"\n            \"\\tWould your like buy a insurance ?\"\n        )\n        self.speak(content=buy_insurance)\n\n    def strategy_trigger(self, deck):\n        if self.is_point(\"<\", BASE_VALUE):\n            self.obtain_card(deck)\n        else:\n            self.trigger += random.randint(0, 5)\n            if self.trigger % 5 == 0:\n                self.obtain_card(deck)\n\n\nclass Player(User):\n    def __init__(self, name, amount):\n        super().__init__(name=name, chips_amount=amount, role=\"Player\", color=\"CYAN\")\n        self.refresh_prompt()\n\n    def refresh_prompt(self):\n        self.prompt = \"{role} [ ${remain} ] >> ({name}) : \".format(\n            role=\"Player\", name=self.name, remain=self.chips.current_amount()\n        )\n\n    def select_choice(self, pattern):\n        my_turn = \"My turn now.\"\n        self.speak(content=my_turn)\n        operation = {\n            \"I\": \"Insurance\",\n            \"H\": \"Hit\",\n            \"S\": \"Stand\",\n            \"D\": \"Double-down\",\n            \"U\": \"Surrender\",\n        }\n        enu_choice = enumerate((operation.get(p) for p in pattern), 1)\n        dict_choice = dict(enu_choice)\n        for index, operator in dict_choice.items():\n            choice_fmt = \"\\t[{index}] {operation}\"\n            print(choice_fmt.format(index=index, operation=operator))\n        return dict_choice\n\n\nclass Recorder:\n    def __init__(self):\n        self.data = []\n        self.winner = None\n        self.remain_chips = 0\n        self.rounds = 0\n        self.player_win_count = 0\n        self.dealer_win_count = 0\n        self.player_point = 0\n        self.dealer_point = 0\n\n    def update(self, winner, chips, player_point, dealer_point):\n        self.rounds += 1\n        self.remain_chips = chips\n        self.winner = winner\n        if self.winner == \"Player\":\n            self.player_win_count += 1\n        elif self.winner == \"Dealer\":\n            self.dealer_win_count += 1\n        self.player_point = player_point\n        self.dealer_point = dealer_point\n\n    def record(self, winner, chips, player_point, dealer_point):\n        self.update(winner, chips, player_point, dealer_point)\n        Row = namedtuple(\n            \"Row\", [\"rounds\", \"player_point\", \"dealer_point\", \"winner\", \"remain_chips\"]\n        )\n        row = Row(\n            self.rounds,\n            self.player_point,\n            self.dealer_point,\n            self.winner,\n            self.remain_chips,\n        )\n        self.data.append(row)\n\n    def draw_diagram(self):\n        content = \"Record display\"\n        bars = \"--\" * 14\n        content_bar = bars + content + bars\n        base_bar = bars + \"-\" * len(content) + bars\n\n        os.system(\"clear\")\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n        self.digram()\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n\n    def digram(self):\n        title = \"Round\\tPlayer-Point\\tDealer-Point\\tWinner-is\\tRemain-Chips\"\n        row_fmt = \"{}\\t{}\\t\\t{}\\t\\t{}\\t\\t{}\"\n\n        print(title)\n        for row in self.data:\n            print(\n                row_fmt.format(\n                    row.rounds,\n                    row.player_point,\n                    row.dealer_point,\n                    row.winner,\n                    row.remain_chips,\n                )\n            )\n\n        print(\"\")\n        win_rate_fmt = \">> Player win rate: {}%\\n>> Dealer win rate: {}%\"\n        try:\n            player_rate = round(self.player_win_count / self.rounds * 100, 2)\n            dealer_rate = round(self.dealer_win_count / self.rounds * 100, 2)\n        except ZeroDivisionError:\n            player_rate = 0\n            dealer_rate = 0\n        print(win_rate_fmt.format(player_rate, dealer_rate))\n\n\nclass BlackJack:\n    def __init__(self, username):\n        self.deck = Deck()\n        self.dealer = Dealer(\"Bob\")\n        self.player = Player(username.title(), 1000)\n        self.recorder = Recorder()\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.res = None\n\n    def play(self):\n        while self.player.chips:\n            self.initial_game()\n            self.in_bet()\n            self.deal_card()\n            while self.go_on:\n                self.choice = self.menu()\n                # self.player.speak()\n                self.chips_manage()\n                try:\n                    self.card_manage()\n                except ValueError as res:\n                    self.bust = True\n                    self.go_on = False\n                    self.res = res\n            if not self.bust:\n                self.is_surrender()\n            self.winner = self.get_winner()\n            self.res = \"Winner is \" + self.winner\n            os.system(\"clear\")\n            self.calculate_chips()\n            self.result_exhibit()\n            self.dealer.unveiling()\n            self.player.unveiling()\n            self.recorder.record(\n                self.winner,\n                self.player.chips.amount,\n                self.player.point,\n                self.dealer.point,\n            )\n\n        self.recorder.draw_diagram()\n        ending = \"\\n\\tSorry I lost all chips!\\n\\tTime to say goodbye.\"\n        self.player.speak(ending)\n        print(\"\\n\" + \"-\" * 20 + \" End Game \" + \"-\" * 20)\n\n    def initial_game(self):\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.deck.rebuilt()\n        self.deck.shuffle()\n        self.player.chips.reset_chip()\n        self.player.drop_card()\n        self.player.refresh_prompt()\n        self.dealer.drop_card()\n        print(\"\\n\" + \"-\" * 20 + \" Start Game \" + \"-\" * 20)\n\n    def in_bet(self):\n        in_bet = \"\\n\\tI want to bet: \"\n        not_invalid = True\n        self.player.speak(in_bet, end_char=\"\")\n        while not_invalid:\n            try:\n                self.player.chips.bet_amount = input()\n            except ValueError as e:\n                print(e)\n                self.player.speak(in_bet, end_char=\"\")\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                self.recorder.draw_diagram()\n                quit()\n            else:\n                self.player.refresh_prompt()\n                # self.player.speak()\n                not_invalid = False\n\n    def deal_card(self):\n        # dealer\n        self.dealer.obtain_card(self.deck, face=False)\n        self.dealer.obtain_card(self.deck)\n\n        # player\n        self.player.obtain_card(self.deck)\n        self.player.obtain_card(self.deck)\n\n        self.dealer.showing()\n        self.player.showing()\n\n    def menu(self):\n        pattern = \"HS\"\n        if self.first_hand:\n            pattern += \"U\"\n            if self.dealer.hand[1].rank == 1 and self.player.chips.current_amount():\n                pattern += \"I\"\n                self.dealer.ask_insurance()\n            if self.player.is_point(\">\", 10) and self.player.chips.can_double():\n                pattern += \"D\"\n            self.first_hand = False\n        choices = self.",
        "middle": "player.select_choice(pattern)\n        select = self.get_select(len(choices), general_err=\"Select above number.\")",
        "suffix": "\n        return choices[select]\n\n    @staticmethod\n    def get_select(select_max, prompt=\">> \", general_err=\"\"):\n        while True:\n            try:\n                value = input(prompt)\n                select = int(value)\n                if select > select_max:\n                    raise ValueError\n            except ValueError:\n                print(general_err)\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                quit()\n            else:\n                return select\n\n    def chips_manage(self):\n        if self.choice == \"Insurance\":\n            err = \"The amount should under \" + str(self.player.chips.current_amount())\n            pay_ins = self.get_select(\n                self.player.chips.current_amount(),\n                prompt=\"Insurance amount >> \",\n                general_err=err,\n            )\n            self.player.chips.insurance = pay_ins\n\n        if self.choice == \"Double-down\":\n            try:\n                self.player.chips.double_bet()\n            except ValueError as e:\n                print(e)\n        self.player.refresh_prompt()\n        if self.choice in (\"Insurance\", \"Double-down\", \"Surrender\"):\n            self.go_on = False\n\n    def card_manage(self):\n        if self.choice in (\"Hit\", \"Double-down\"):\n            self.player.obtain_card(self.deck)\n            if self.player.is_point(\">\", BLACK_JACK):\n                raise ValueError(\"Player BUST\")\n            else:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n        elif self.choice != \"Surrender\":\n            if not self.player.chips.is_insurance:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n\n        self.dealer.showing()\n        self.player.showing()\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.go_on = False\n\n    def is_surrender(self):\n        if self.choice == \"Surrender\":\n            self.player.speak(\"Sorry, I surrender....\\n\")\n\n    def get_winner(self):\n        if self.bust:\n            return \"Dealer\" if self.player.is_point(\">\", BLACK_JACK) else \"Player\"\n\n        if self.choice == \"Surrender\":\n            return \"Dealer\"\n        elif self.choice == \"Insurance\":\n            if self.player.is_point(\"==\", BLACK_JACK):\n                return \"Dealer\"\n            return \"Player\"\n\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.player.calculate_point()\n            self.dealer.calculate_point()\n            if self.player.point > self.dealer.point:\n                return \"Player\"\n            return \"Dealer\"\n\n        return \"Both\"\n\n    def calculate_chips(self):\n        if self.choice == \"Surrender\":\n            if self.player.chips.bet_amount == 1:\n                if self.player.chips.current_amount() == 0:\n                    self.player.chips.amount = 0\n            else:\n                surrender_amount = self.player.chips.bet_amount // 2\n                self.player.chips.amount -= surrender_amount\n\n        elif self.choice in (\"Double-down\", \"Stand\", \"Insurance\", \"Hit\"):\n            if self.winner == \"Player\":\n                self.player.chips.amount += (\n                    self.player.chips.bet_amount + self.player.chips.insurance * 2\n                )\n            elif self.winner == \"Dealer\":\n                self.player.chips.amount -= (\n                    self.player.chips.bet_amount + self.player.chips.insurance\n                )\n\n    def result_exhibit(self):\n        def get_color():\n            if \"BUST\" in content:\n                return COLOR.get(\"RED\" if \"Player\" in content else \"GREEN\")\n            if self.winner == \"Player\":\n                return COLOR.get(\"GREEN\")\n            elif self.winner == \"Dealer\":\n                return COLOR.get(\"RED\")\n            else:\n                return COLOR.get(\"YELLOW\")\n\n        end = COLOR.get(\"END\")\n        content = str(self.res)\n        color = get_color()\n        winner_fmt = color + \"\\n\\t>> {content} <<\\n\" + end\n        print(winner_fmt.format(content=content))\n\n\ndef main():\n    try:\n        user_name = input(\"What is your name: \")\n    except KeyboardInterrupt:\n        print(\"\")\n    else:\n        black_jack = BlackJack(username=user_name)\n        black_jack.play()\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
        "id": 8,
        "filename": "5.txt",
        "prefix": "\nimport os\nimport random\nfrom functools import namedtuple\n\n\"\"\"\nTarget: BlackJack 21 simulate\n    - Role\n        - Dealer: 1\n            - Insurance: (When dealer Get A(1) face up)\n                - When dealer got 21\n                    - lost chips\n                - When dealer doesn't got 21\n                    - win double chips (Your Insurance)\n        - Player: 1\n            - Bet: (Drop chip before gambling start)\n            - Hit: (Take other card from the dealer)\n            - Stand: (No more card dealer may take card when rank under 17)\n            - Double down: (When you got over 10 in first hand)\n                           (Get one card)\n            - Surrender: (only available as first decision of a hand)\n                - Dealer return 50% chips\n\"\"\"\n\n__author__ = \"Alopex Cheung\"\n__version__ = \"0.2\"\n\nBLACK_JACK = 21\nBASE_VALUE = 17\n\nCOLOR = {\n    \"PURPLE\": \"\\033[1;35;48m\",\n    \"CYAN\": \"\\033[1;36;48m\",\n    \"BOLD\": \"\\033[1;37;48m\",\n    \"BLUE\": \"\\033[1;34;48m\",\n    \"GREEN\": \"\\033[1;32;48m\",\n    \"YELLOW\": \"\\033[1;33;48m\",\n    \"RED\": \"\\033[1;31;48m\",\n    \"BLACK\": \"\\033[1;30;48m\",\n    \"UNDERLINE\": \"\\033[4;37;48m\",\n    \"END\": \"\\033[1;37;0m\",\n}\n\n\nclass Card:\n    __slots__ = \"suit\", \"rank\", \"is_face\"\n\n    def __init__(self, suit, rank, face=True):\n        \"\"\"\n        :param suit: patter in the card\n        :param rank: point in the card\n        :param face: show or cover the face(point & pattern on it)\n        \"\"\"\n        self.suit = suit\n        self.rank = rank\n        self.is_face = face\n\n    def __repr__(self):\n        fmt_card = \"\\t<rank: {rank:2}, suit: {suit:8}>\"\n        if self.is_face:\n            return fmt_card.format(suit=self.suit, rank=self.rank)\n        return fmt_card.format(suit=\"*-Back-*\", rank=\"*-Back-*\")\n\n    def show(self):\n        print(str(self))\n\n\nclass Deck:\n    def __init__(self, num=1):\n        \"\"\"\n        :param num: the number of deck\n        \"\"\"\n        self.num = num\n        self.cards = []\n        self.built()\n\n    def __repr__(self):\n        return \"\\n\".join([str(card) for card in self.cards])\n\n    def __len__(self):\n        return len(self.cards)\n\n    def built(self):\n        for _ in range(self.num):\n            ranks = [x for x in range(1, 14)]\n            suits = \"Spades Heart Clubs Diamonds\".split()\n            for suit in suits:\n                for rank in ranks:\n                    card = Card(suit, rank)\n                    self.cards.append(card)\n\n    def shuffle(self):\n        for _ in range(self.num):\n            for index in range(len(self.cards)):\n                i = random.randint(0, 51)\n                self.cards[index], self.cards[i] = self.cards[i], self.cards[index]\n\n    def rebuilt(self):\n        self.cards.clear()\n        self.built()\n\n    def deliver(self):\n        return self.cards.pop()\n\n\nclass Chips:\n    def __init__(self, amount):\n        \"\"\"\n        :param amount: the chips you own\n        \"\"\"\n        self._amount = amount\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_insurance = False\n        self.is_double = False\n\n    def __bool__(self):\n        return self.amount > 0\n\n    @staticmethod\n    def get_tips(content):\n        fmt_tips = \"{color}** TIPS: {content}! **{end}\"\n        return fmt_tips.format(\n            color=COLOR.get(\"YELLOW\"), content=content, end=COLOR.get(\"END\")\n        )\n\n    @property\n    def amount(self):\n        return self._amount\n\n    @amount.setter\n    def amount(self, value):\n        if not isinstance(value, int):\n            type_tips = \"Please give a integer\"\n            raise ValueError(Chips.get_tips(type_tips))\n        if value < 0:\n            amount_tips = \"Your integer should bigger than 0\"\n            raise ValueError(Chips.get_tips(amount_tips))\n        self._amount = value\n\n    @property\n    def bet_amount(self):\n        return self._bet_amount\n\n    @bet_amount.setter\n    def bet_amount(self, value):\n        type_tips = \"Please give a integer\"\n        amount_tips = \"Your chips should between 1 - \" + str(self.amount) + ",
        "middle": "\" \"\n",
        "suffix": "        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(Chips.get_tips(type_tips))\n        else:\n            if not isinstance(value, int):\n                raise ValueError(Chips.get_tips(type_tips))\n            if (value <= 0) or (value > self.amount):\n                raise ValueError(Chips.get_tips(amount_tips))\n            self._bet_amount = value\n\n    def double_bet(self):\n        if self.can_double():\n            self._bet_amount *= 2\n            self.is_double = True\n        else:\n            over_tips = \"Not enough chips || \"\n            cannot_double = \"CAN'T DO DOUBLE\"\n            raise ValueError(Chips.get_tips(over_tips + cannot_double))\n\n    @property\n    def insurance(self):\n        return self._insurance\n\n    @insurance.setter\n    def insurance(self, value):\n        if self.amount - value < 0:\n            over_tips = \"Not enough chips\"\n            raise ValueError(Chips.get_tips(over_tips))\n        self._insurance = value\n        self.is_insurance = True\n\n    def current_amount(self):\n        return self.amount - self.bet_amount - self.insurance\n\n    def reset_chip(self):\n        self._bet_amount = 0\n        self._insurance = 0\n        self.is_double = False\n        self.is_insurance = False\n\n    def can_double(self):\n        return self.current_amount() - self.bet_amount >= 0\n\n\nclass User:\n    def __init__(self, name, role, chips_amount=None, color=\"END\"):\n        \"\"\"\n        :param name: User name\n        :param role: dealer or player\n        :param chips_amount: Casino tokens equal money\n        \"\"\"\n        self.name = name\n        self.prompt = \"{role} >> ({name}) : \".format(role=role, name=self.name)\n        self.chips = Chips(chips_amount)\n        self.color = color\n        self.hand = []\n        self.point = 0\n\n    def __repr__(self):\n        return str(self.__dict__)\n\n    def obtain_card(self, deck, face=True):\n        card = deck.deliver()\n        card.is_face = face\n        self.hand.append(card)\n\n    def drop_card(self):\n        self.hand.clear()\n        self.point = 0\n\n    def show_card(self):\n        print(\"\\t    ** Here is my card **\")\n        for card in self.hand:\n            card.show()\n\n    def unveil_card(self):\n        for card in self.hand:\n            card.is_face = True\n        self.show_card()\n\n    def calculate_point(self):\n        def _extract_rank():\n            raw_ranks = [card.rank for card in self.hand]\n            cook_ranks = [10 if rank > 10 else rank for rank in raw_ranks]\n            return cook_ranks\n\n        def _sum_up(ranks):\n            rank_one = sum(ranks)\n            rank_eleven = sum([11 if rank == 1 else rank for rank in ranks])\n            # Over or has 2 Ace\n            if (ranks[::-1] == ranks) and (1 in ranks):\n                return 11 + len(ranks) - 1\n            if rank_eleven <= BLACK_JACK:\n                return rank_eleven\n            return rank_one\n\n        points = _extract_rank()\n        self.point = _sum_up(points)\n\n    def is_point(self, opt, point):\n        self.calculate_point()\n        compare_fmt = \"{user_point} {opt} {point}\".format(\n            user_point=self.point, opt=opt, point=point\n        )\n        return eval(compare_fmt)\n\n    def speak(self, content=\"\", end_char=\"\\n\"):\n        print(\"\")\n        print(\n            COLOR.get(self.color) + self.prompt + COLOR.get(\"END\") + content,\n            end=end_char,\n        )\n\n    def showing(self):\n        self.speak()\n        self.show_card()\n\n    def unveiling(self):\n        self.calculate_point()\n        points_fmt = \"My point is: {}\".format(str(self.point))\n        self.speak(points_fmt)\n        self.unveil_card()\n\n\nclass Dealer(User):\n    def __init__(self, name):\n        super().__init__(name=name, role=\"Dealer\", color=\"PURPLE\")\n        self.trigger = 0\n\n    def ask_insurance(self):\n        buy_insurance = (\n            \"(Insurance pay 2 to 1)\\n\"\n            \"\\tMy Face card is an Ace.\\n\"\n            \"\\tWould your like buy a insurance ?\"\n        )\n        self.speak(content=buy_insurance)\n\n    def strategy_trigger(self, deck):\n        if self.is_point(\"<\", BASE_VALUE):\n            self.obtain_card(deck)\n        else:\n            self.trigger += random.randint(0, 5)\n            if self.trigger % 5 == 0:\n                self.obtain_card(deck)\n\n\nclass Player(User):\n    def __init__(self, name, amount):\n        super().__init__(name=name, chips_amount=amount, role=\"Player\", color=\"CYAN\")\n        self.refresh_prompt()\n\n    def refresh_prompt(self):\n        self.prompt = \"{role} [ ${remain} ] >> ({name}) : \".format(\n            role=\"Player\", name=self.name, remain=self.chips.current_amount()\n        )\n\n    def select_choice(self, pattern):\n        my_turn = \"My turn now.\"\n        self.speak(content=my_turn)\n        operation = {\n            \"I\": \"Insurance\",\n            \"H\": \"Hit\",\n            \"S\": \"Stand\",\n            \"D\": \"Double-down\",\n            \"U\": \"Surrender\",\n        }\n        enu_choice = enumerate((operation.get(p) for p in pattern), 1)\n        dict_choice = dict(enu_choice)\n        for index, operator in dict_choice.items():\n            choice_fmt = \"\\t[{index}] {operation}\"\n            print(choice_fmt.format(index=index, operation=operator))\n        return dict_choice\n\n\nclass Recorder:\n    def __init__(self):\n        self.data = []\n        self.winner = None\n        self.remain_chips = 0\n        self.rounds = 0\n        self.player_win_count = 0\n        self.dealer_win_count = 0\n        self.player_point = 0\n        self.dealer_point = 0\n\n    def update(self, winner, chips, player_point, dealer_point):\n        self.rounds += 1\n        self.remain_chips = chips\n        self.winner = winner\n        if self.winner == \"Player\":\n            self.player_win_count += 1\n        elif self.winner == \"Dealer\":\n            self.dealer_win_count += 1\n        self.player_point = player_point\n        self.dealer_point = dealer_point\n\n    def record(self, winner, chips, player_point, dealer_point):\n        self.update(winner, chips, player_point, dealer_point)\n        Row = namedtuple(\n            \"Row\", [\"rounds\", \"player_point\", \"dealer_point\", \"winner\", \"remain_chips\"]\n        )\n        row = Row(\n            self.rounds,\n            self.player_point,\n            self.dealer_point,\n            self.winner,\n            self.remain_chips,\n        )\n        self.data.append(row)\n\n    def draw_diagram(self):\n        content = \"Record display\"\n        bars = \"--\" * 14\n        content_bar = bars + content + bars\n        base_bar = bars + \"-\" * len(content) + bars\n\n        os.system(\"clear\")\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n        self.digram()\n        print(base_bar)\n        print(content_bar)\n        print(base_bar)\n\n    def digram(self):\n        title = \"Round\\tPlayer-Point\\tDealer-Point\\tWinner-is\\tRemain-Chips\"\n        row_fmt = \"{}\\t{}\\t\\t{}\\t\\t{}\\t\\t{}\"\n\n        print(title)\n        for row in self.data:\n            print(\n                row_fmt.format(\n                    row.rounds,\n                    row.player_point,\n                    row.dealer_point,\n                    row.winner,\n                    row.remain_chips,\n                )\n            )\n\n        print(\"\")\n        win_rate_fmt = \">> Player win rate: {}%\\n>> Dealer win rate: {}%\"\n        try:\n            player_rate = round(self.player_win_count / self.rounds * 100, 2)\n            dealer_rate = round(self.dealer_win_count / self.rounds * 100, 2)\n        except ZeroDivisionError:\n            player_rate = 0\n            dealer_rate = 0\n        print(win_rate_fmt.format(player_rate, dealer_rate))\n\n\nclass BlackJack:\n    def __init__(self, username):\n        self.deck = Deck()\n        self.dealer = Dealer(\"Bob\")\n        self.player = Player(username.title(), 1000)\n        self.recorder = Recorder()\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.res = None\n\n    def play(self):\n        while self.player.chips:\n            self.initial_game()\n            self.in_bet()\n            self.deal_card()\n            while self.go_on:\n                self.choice = self.menu()\n                # self.player.speak()\n                self.chips_manage()\n                try:\n                    self.card_manage()\n                except ValueError as res:\n                    self.bust = True\n                    self.go_on = False\n                    self.res = res\n            if not self.bust:\n                self.is_surrender()\n            self.winner = self.get_winner()\n            self.res = \"Winner is \" + self.winner\n            os.system(\"clear\")\n            self.calculate_chips()\n            self.result_exhibit()\n            self.dealer.unveiling()\n            self.player.unveiling()\n            self.recorder.record(\n                self.winner,\n                self.player.chips.amount,\n                self.player.point,\n                self.dealer.point,\n            )\n\n        self.recorder.draw_diagram()\n        ending = \"\\n\\tSorry I lost all chips!\\n\\tTime to say goodbye.\"\n        self.player.speak(ending)\n        print(\"\\n\" + \"-\" * 20 + \" End Game \" + \"-\" * 20)\n\n    def initial_game(self):\n        self.go_on = True\n        self.first_hand = True\n        self.choice = None\n        self.winner = None\n        self.bust = False\n        self.deck.rebuilt()\n        self.deck.shuffle()\n        self.player.chips.reset_chip()\n        self.player.drop_card()\n        self.player.refresh_prompt()\n        self.dealer.drop_card()\n        print(\"\\n\" + \"-\" * 20 + \" Start Game \" + \"-\" * 20)\n\n    def in_bet(self):\n        in_bet = \"\\n\\tI want to bet: \"\n        not_invalid = True\n        self.player.speak(in_bet, end_char=\"\")\n        while not_invalid:\n            try:\n                self.player.chips.bet_amount = input()\n            except ValueError as e:\n                print(e)\n                self.player.speak(in_bet, end_char=\"\")\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                self.recorder.draw_diagram()\n                quit()\n            else:\n                self.player.refresh_prompt()\n                # self.player.speak()\n                not_invalid = False\n\n    def deal_card(self):\n        # dealer\n        self.dealer.obtain_card(self.deck, face=False)\n        self.dealer.obtain_card(self.deck)\n\n        # player\n        self.player.obtain_card(self.deck)\n        self.player.obtain_card(self.deck)\n\n        self.dealer.showing()\n        self.player.showing()\n\n    def menu(self):\n        pattern = \"HS\"\n        if self.first_hand:\n            pattern += \"U\"\n            if self.dealer.hand[1].rank == 1 and self.player.chips.current_amount():\n                pattern += \"I\"\n                self.dealer.ask_insurance()\n            if self.player.is_point(\">\", 10) and self.player.chips.can_double():\n                pattern += \"D\"\n            self.first_hand = False\n        choices = self.player.select_choice(pattern)\n        select = self.get_select(len(choices), general_err=\"Select above number.\")\n        return choices[select]\n\n    @staticmethod\n    def get_select(select_max, prompt=\">> \", general_err=\"\"):\n        while True:\n            try:\n                value = input(prompt)\n                select = int(value)\n                if select > select_max:\n                    raise ValueError\n            except ValueError:\n                print(general_err)\n                continue\n            except KeyboardInterrupt:\n                print(\"\")\n                quit()\n            else:\n                return select\n\n    def chips_manage(self):\n        if self.choice == \"Insurance\":\n            err = \"The amount should under \" + str(self.player.chips.current_amount())\n            pay_ins = self.get_select(\n                self.player.chips.current_amount(),\n                prompt=\"Insurance amount >> \",\n                general_err=err,\n            )\n            self.player.chips.insurance = pay_ins\n\n        if self.choice == \"Double-down\":\n            try:\n                self.player.chips.double_bet()\n            except ValueError as e:\n                print(e)\n        self.player.refresh_prompt()\n        if self.choice in (\"Insurance\", \"Double-down\", \"Surrender\"):\n            self.go_on = False\n\n    def card_manage(self):\n        if self.choice in (\"Hit\", \"Double-down\"):\n            self.player.obtain_card(self.deck)\n            if self.player.is_point(\">\", BLACK_JACK):\n                raise ValueError(\"Player BUST\")\n            else:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n        elif self.choice != \"Surrender\":\n            if not self.player.chips.is_insurance:\n                self.dealer.strategy_trigger(self.deck)\n                if self.dealer.is_point(\">\", BLACK_JACK):\n                    raise ValueError(\"Dealer BUST\")\n\n        self.dealer.showing()\n        self.player.showing()\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.go_on = False\n\n    def is_surrender(self):\n        if self.choice == \"Surrender\":\n            self.player.speak(\"Sorry, I surrender....\\n\")\n\n    def get_winner(self):\n        if self.bust:\n            return \"Dealer\" if self.player.is_point(\">\", BLACK_JACK) else \"Player\"\n\n        if self.choice == \"Surrender\":\n            return \"Dealer\"\n        elif self.choice == \"Insurance\":\n            if self.player.is_point(\"==\", BLACK_JACK):\n                return \"Dealer\"\n            return \"Player\"\n\n        if self.choice in (\"Double-down\", \"Stand\"):\n            self.player.calculate_point()\n            self.dealer.calculate_point()\n            if self.player.point > self.dealer.point:\n                return \"Player\"\n            return \"Dealer\"\n\n        return \"Both\"\n\n    def calculate_chips(self):\n        if self.choice == \"Surrender\":\n            if self.player.chips.bet_amount == 1:\n                if self.player.chips.current_amount() == 0:\n                    self.player.chips.amount = 0\n            else:\n                surrender_amount = self.player.chips.bet_amount // 2\n                self.player.chips.amount -= surrender_amount\n\n        elif self.choice in (\"Double-down\", \"Stand\", \"Insurance\", \"Hit\"):\n            if self.winner == \"Player\":\n                self.player.chips.amount += (\n                    self.player.chips.bet_amount + self.player.chips.insurance * 2\n                )\n            elif self.winner == \"Dealer\":\n                self.player.chips.amount -= (\n                    self.player.chips.bet_amount + self.player.chips.insurance\n                )\n\n    def result_exhibit(self):\n        def get_color():\n            if \"BUST\" in content:\n                return COLOR.get(\"RED\" if \"Player\" in content else \"GREEN\")\n            if self.winner == \"Player\":\n                return COLOR.get(\"GREEN\")\n            elif self.winner == \"Dealer\":\n                return COLOR.get(\"RED\")\n            else:\n                return COLOR.get(\"YELLOW\")\n\n        end = COLOR.get(\"END\")\n        content = str(self.res)\n        color = get_color()\n        winner_fmt = color + \"\\n\\t>> {content} <<\\n\" + end\n        print(winner_fmt.format(content=content))\n\n\ndef main():\n    try:\n        user_name = input(\"What is your name: \")\n    except KeyboardInterrupt:\n        print(\"\")\n    else:\n        black_jack = BlackJack(username=user_name)\n        black_jack.play()\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
        "id": 9,
        "filename": "4.txt",
        "prefix": "\n# master\n# master\n# BLACK JACK - CASINO A GAME OF FORTUNE!!!\nfrom time import sleep\n\n# BLACK JACK - CASINO\n# PYTHON CODE BASE\n\n\n# master\nimport random\n\ndeck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 11] * 4\n\nrandom.shuffle(deck)\n\nprint(f'{\"*\"*58} \\n Welcome to the game Casino - BLACK JACK ! \\n{\"*\"*58}')\nsleep(2)\nprint(\"So Finally You Are Here To Accept Your Fate\")\nsleep(2)\nprint(\"I Mean Your Fortune\")\nsleep(2)\nprint(\"Lets Check How Lucky You Are  Wish You All The Best\")\nsleep(2)\nprint(\"Loading---\")\nsleep(2)\n\nprint(\"Still Loading---\")\nsleep(2)\nprint(\n    \"So You Are Still Here Not Gone I Gave You Chance But No Problem May Be You Trust Your Fortune A Lot \\n Lets Begin Then\"\n)\nsleep(2)\nd_cards = []  # Initialising dealer's cards\np_cards = []  # Initialising player's cards\nsleep(2)\nwhile len(d_cards) != 2:\n    random.shuffle(deck)\n    d_cards.append(deck.pop())\n    if len(d_cards) == 2:\n        print(\"The cards dealer has are X \", d_cards[1])\n\n# Displaying the Player's cards\nwhile len(p_cards) != 2:\n    random.shuffle(deck)\n    p_cards.append(deck.pop())\n    if len(p_cards) == 2:\n        print(\"The total of player is \", sum(p_cards))\n        print(\"The cards Player has are  \", p_cards)\n\nif sum(p_cards) > 21:\n    print(f\"You are BUSTED !\\n  {'*'*14}Dealer ",
        "middle": "Wins ",
        "suffix": "!!{'*'*14}\\n\")\n    exit()\n\nif sum(d_cards) > 21:\n    print(f\"Dealer is BUSTED !\\n   {'*'*14} You are the Winner !!{'*'*18}\\n\")\n    exit()\n\nif sum(d_cards) == 21:\n    print(f\"{'*'*24}Dealer is the Winner !!{'*'*14}\")\n    exit()\n\nif sum(d_cards) == 21 and sum(p_cards) == 21:\n    print(f\"{'*'*17}The match is tie !!{'*'*25}\")\n    exit()\n\n\n# function to show the dealer's choice\ndef dealer_choice():\n    if sum(d_cards) < 17:\n        while sum(d_cards) < 17:\n            random.shuffle(deck)\n            d_cards.append(deck.pop())\n\n    print(\"Dealer has total \" + str(sum(d_cards)) + \"with the cards \", d_cards)\n\n    if sum(p_cards) == sum(d_cards):\n        print(f\"{'*'*15}The match is tie !!{'*'*15}\")\n        exit()\n\n    if sum(d_cards) == 21:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*20}There is tie !!{'*'*26}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n    elif sum(d_cards) < 21:\n        if sum(p_cards) < 21 and sum(p_cards) < sum(d_cards):\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        if sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        if 21 > sum(p_cards) > sum(d_cards):\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n\n    else:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n\nwhile sum(p_cards) < 21:\n\n    # to continue the game again and again !!\n    k = input(\"Want to hit or stay?\\n Press 1 for hit and 0 for stay \")\n    if k == \"1\": #Ammended 1 to a string\n        random.shuffle(deck)\n        p_cards.append(deck.pop())\n        print(\"You have a total of \" + str(sum(p_cards)) + \" with the cards \", p_cards)\n        if sum(p_cards) > 21:\n            print(f'{\"*\"*13}You are BUSTED !{\"*\"*13}\\n Dealer Wins !!')\n        if sum(p_cards) == 21:\n            print(f'{\"*\"*19}You are the Winner !!{\"*\"*29}')\n\n    else:\n        dealer_choice()\n        break\n"
    },
    {
        "id": 10,
        "filename": "4.txt",
        "prefix": "\n# master\n# master\n# BLACK JACK - CASINO A GAME OF FORTUNE!!!\nfrom time import sleep\n\n# BLACK JACK - CASINO\n# PYTHON CODE BASE\n\n\n# master\nimport random\n\ndeck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 11] * 4\n\nrandom.shuffle(deck)\n\nprint(f'{\"*\"*58} \\n Welcome to the game Casino - BLACK JACK ! \\n{\"*\"*58}')\nsleep(2)\nprint(\"So Finally You Are Here To Accept Your Fate\")\nsleep(2)\nprint(\"I Mean Your Fortune\")\nsleep(2)\nprint(\"Lets Check How Lucky You Are  Wish You All The Best\")\nsleep(2)\nprint(\"Loading---\")\nsleep(2)\n\nprint(\"Still Loading---\")\nsleep(2)\nprint(\n    \"So You Are Still Here Not Gone I Gave You Chance But No Problem May Be You Trust Your Fortune A Lot \\n Lets Begin Then\"\n)\nsleep(2)\nd_cards = []  # Initialising dealer's cards\np_cards = []  # Initialising player's cards\nsleep(2)\nwhile len(d_cards) != 2:\n    random.shuffle(deck)\n    d_cards.append(deck.pop())\n    if len(d_cards) == 2:\n        print(\"The cards dealer has are X \", d_cards[1])\n\n# Displaying the Player's cards\nwhile len(p_cards) != 2:\n    random.shuffle(deck)\n    p_cards.append(deck.pop())\n    if len(p_cards) == 2:\n        print(\"The total of player is \", sum(p_cards))\n        print(\"The cards Player has are  \", p_cards)\n\nif sum(p_cards) > 21:\n    print(f\"You are BUSTED !\\n  {'*'*14}Dealer Wins !!{'*'*14}\\n\")\n    exit()\n\nif sum(d_cards) > 21:\n    print(f\"Dealer is BUSTED !\\n   {'*'*14} You are the Winner !!{'*'*18}\\n\")\n    exit()\n\nif sum(d_cards) == 21:\n    print(f\"{'*'*24}Dealer is the Winner !!{'*'*14}\")\n    exit()\n\nif sum(d_cards) == 21 and sum(p_cards) == 21:\n    print(f\"{'*'*17}The match is tie !!{'*'*25}\")\n    exit()\n\n\n# function to show the dealer's choice\ndef dealer_choice():\n    if sum(d_cards) < 17:\n        while sum(d_cards) < 17:\n            random.shuffle(deck)\n            d_cards.append(deck.pop())\n\n    print(\"Dealer has total \" + str(sum(d_cards)) + \"with the cards \", d_cards)\n\n    if sum(p_cards) == sum(d_cards):\n        print(f\"{'*'*15}The match is tie !!{'*'*15}\"",
        "middle": ")\n        exit()\n\n    if sum",
        "suffix": "(d_cards) == 21:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*20}There is tie !!{'*'*26}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n    elif sum(d_cards) < 21:\n        if sum(p_cards) < 21 and sum(p_cards) < sum(d_cards):\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        if sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        if 21 > sum(p_cards) > sum(d_cards):\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n\n    else:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n\nwhile sum(p_cards) < 21:\n\n    # to continue the game again and again !!\n    k = input(\"Want to hit or stay?\\n Press 1 for hit and 0 for stay \")\n    if k == \"1\": #Ammended 1 to a string\n        random.shuffle(deck)\n        p_cards.append(deck.pop())\n        print(\"You have a total of \" + str(sum(p_cards)) + \" with the cards \", p_cards)\n        if sum(p_cards) > 21:\n            print(f'{\"*\"*13}You are BUSTED !{\"*\"*13}\\n Dealer Wins !!')\n        if sum(p_cards) == 21:\n            print(f'{\"*\"*19}You are the Winner !!{\"*\"*29}')\n\n    else:\n        dealer_choice()\n        break\n"
    },
    {
        "id": 11,
        "filename": "4.txt",
        "prefix": "\n# master\n# master\n# BLACK JACK - CASINO A GAME OF FORTUNE!!!\nfrom time import sleep\n\n# BLACK JACK - CASINO\n# PYTHON CODE BASE\n\n\n# master\nimport random\n\ndeck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 11] * 4\n\nrandom.shuffle(deck)\n\nprint(f'{\"*\"*58} \\n Welcome to the game Casino - BLACK JACK ! \\n{\"*\"*58}')\nsleep(2)\nprint(\"So Finally You Are Here To Accept Your Fate\")\nsleep(2)\nprint(\"I Mean Your Fortune\")\nsleep(2)\nprint(\"Lets Check How Lucky You Are  Wish You All The Best\")\nsleep(2)\nprint(\"Loading---\")\nsleep(2)\n\nprint(\"Still Loading---\")\nsleep(2)\nprint(\n    \"So You Are Still Here Not Gone I Gave You Chance But No Problem May Be You Trust Your Fortune A Lot \\n Lets Begin Then\"\n)\nsleep(2)\nd_cards = []  # Initialising dealer's cards\np_cards = []  # Initialising player's cards\nsleep(2)\nwhile len(d_cards) != 2:\n    random.shuffle(deck)\n    d_cards.append(deck.pop())\n    if len(d_cards) == 2:\n        print(\"The cards dealer has are X \", d_cards[1])\n\n# Displaying the Player's cards\nwhile len(p_cards) != 2:\n    random.shuffle(deck)\n    p_cards.append(deck.pop())\n    if len(p_cards) == 2:\n        print(\"The total of player is \", sum(p_cards))\n        print(\"The cards Player has are  \", p_cards)\n\nif sum(p_cards) > 21:\n    print(f\"You are BUSTED !\\n  {'*'*14}Dealer Wins !!{'*'*14}\\n\")\n    exit()\n\nif sum(d_cards) > 21:\n    print(f\"Dealer is BUSTED !\\n   {'*'*14} You are the Winner !!{'*'*18}\\n\")\n    exit()\n\nif sum(d_cards) == 21:\n    print(f\"{'*'*24}Dealer is the Winner !!{'*'*14}\")\n    exit()\n\nif sum(d_cards) == 21 and sum(p_cards) == 21:\n    print(f\"{'*'*17}The match is tie !!{'*'*25}\")\n    exit()\n\n\n# function to show the dealer's choice\ndef dealer_choice():\n    if sum(d_cards) < 17:\n        while sum(d_cards) < 17:\n            random.shuffle(deck)\n            d_cards.append(deck.pop())\n\n    print(\"Dealer has total \" + str(sum(d_cards)) + \"with the cards \", d_cards)\n\n    if sum(p_cards) == sum(d_cards):\n        print(f\"{'*'*15}The match is tie !!{'*'*15}\")\n        exit()\n\n    if sum(d_cards) == 21:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*20}There is tie !!{'*'*26}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n    elif sum(d_cards) < 21:\n        if sum(p_cards) < 21 and sum(p_cards) < sum(d_cards):\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        if sum(p_cards) == 21:\n         ",
        "middle": "   print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        if 21",
        "suffix": " > sum(p_cards) > sum(d_cards):\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n\n    else:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n\nwhile sum(p_cards) < 21:\n\n    # to continue the game again and again !!\n    k = input(\"Want to hit or stay?\\n Press 1 for hit and 0 for stay \")\n    if k == \"1\": #Ammended 1 to a string\n        random.shuffle(deck)\n        p_cards.append(deck.pop())\n        print(\"You have a total of \" + str(sum(p_cards)) + \" with the cards \", p_cards)\n        if sum(p_cards) > 21:\n            print(f'{\"*\"*13}You are BUSTED !{\"*\"*13}\\n Dealer Wins !!')\n        if sum(p_cards) == 21:\n            print(f'{\"*\"*19}You are the Winner !!{\"*\"*29}')\n\n    else:\n        dealer_choice()\n        break\n"
    },
    {
        "id": 12,
        "filename": "4.txt",
        "prefix": "\n# master\n# master\n# BLACK JACK - CASINO A GAME OF FORTUNE!!!\nfrom time import sleep\n\n# BLACK JACK - CASINO\n# PYTHON CODE BASE\n\n\n# master\nimport random\n\ndeck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 11] * 4\n\nrandom.shuffle(deck)\n\nprint(f'{\"*\"*58} \\n Welcome to the game Casino - BLACK JACK ! \\n{\"*\"*58}')\nsleep(2)\nprint(\"So Finally You Are Here To Accept Your Fate\")\nsleep(2)\nprint(\"I Mean Your Fortune\")\nsleep(2)\nprint(\"Lets Check How Lucky You Are  Wish You All The Best\")\nsleep(2)\nprint(\"Loading---\")\nsleep(2)\n\nprint(\"Still Loading---\")\nsleep(2)\nprint(\n    \"So You Are Still Here Not Gone I Gave You Chance But No Problem May Be You Trust Your Fortune A Lot \\n Lets Begin Then\"\n)\nsleep(2)\nd_cards = []  # Initialising dealer's cards\np_cards = []  # Initialising player's cards\nsleep(2)\nwhile len(d_cards) != 2:\n    random.shuffle(deck)\n    d_cards.append(deck.pop())\n    if len(d_cards) == 2:\n        print(\"The cards dealer has are X \", d_cards[1])\n\n# Displaying the Player's cards\nwhile len(p_cards) != 2:\n    random.shuffle(deck)\n    p_cards.append(deck.pop())\n    if len(p_cards) == 2:\n        print(\"The total of player is \", sum(p_cards))\n        print(\"The cards Player has are  \", p_cards)\n\nif sum(p_cards) > 21:\n    print(f\"You are BUSTED !\\n  {'*'*14}Dealer Wins !!{'*'*14}\\n\")\n    exit()\n\nif sum(d_cards) > 21:\n    print(f\"Dealer is BUSTED !\\n   {'*'*14} You are the Winner !!{'*'*18}\\n\")\n    exit()\n\nif sum(d_cards) == 21:\n    print(f\"{'*'*24}Dealer is the Winner !!{'*'*14}\")\n    exit()\n\nif sum(d_cards) == 21 and sum(p_cards) == 21:\n    print(f\"{'*'*17}The match is tie !!{'*'*25}\")\n    exit()\n\n\n# function to show the dealer's choice\ndef dealer_choice():\n    if sum(d_cards) < 17:\n        while sum(d_cards) < 17:\n            random.shuffle(deck)\n            d_cards.append(deck.pop())\n\n    print(\"Dealer has total \" + str(sum(d_cards)) + \"with the cards \", d_cards)\n\n    if sum(p_cards) == sum(d_cards):\n        print(f\"{'*'*15}The match is tie !!{'*'*15}\")\n        exit()\n\n    if sum(d_cards) == 21:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*20}There is tie !!{'*'*26}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n    elif sum(d_cards) < 21:\n        if sum(p_cards) < 21 and sum(p_cards) < sum(d_cards):\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        if sum(p_cards",
        "middle": ") == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        if 21 > sum(",
        "suffix": "p_cards) > sum(d_cards):\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n\n    else:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n\nwhile sum(p_cards) < 21:\n\n    # to continue the game again and again !!\n    k = input(\"Want to hit or stay?\\n Press 1 for hit and 0 for stay \")\n    if k == \"1\": #Ammended 1 to a string\n        random.shuffle(deck)\n        p_cards.append(deck.pop())\n        print(\"You have a total of \" + str(sum(p_cards)) + \" with the cards \", p_cards)\n        if sum(p_cards) > 21:\n            print(f'{\"*\"*13}You are BUSTED !{\"*\"*13}\\n Dealer Wins !!')\n        if sum(p_cards) == 21:\n            print(f'{\"*\"*19}You are the Winner !!{\"*\"*29}')\n\n    else:\n        dealer_choice()\n        break\n"
    },
    {
        "id": 13,
        "filename": "4.txt",
        "prefix": "\n# master\n# master\n# BLACK JACK - CASINO A GAME OF FORTUNE!!!\nfrom time import sleep\n\n# BLACK JACK - CASINO\n# PYTHON CODE BASE\n\n\n# master\nimport random\n\ndeck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 11] * 4\n\nrandom.shuffle(deck)\n\nprint(f'{\"*\"*58} \\n Welcome to the game Casino - BLACK JACK ! \\n{\"*\"*58}')\nsleep(2)\nprint(\"So Finally You Are Here To Accept Your Fate\")\nsleep(2)\nprint(\"I Mean Your Fortune\")\nsleep(2)\nprint(\"Lets Check How Lucky You Are  Wish You All The Best\")\nsleep(2)\nprint(\"Loading---\")\nsleep(2)\n\nprint(\"Still Loading---\")\nsleep(2)\nprint(\n    \"So You Are Still Here Not Gone I Gave You Chance But No Problem May Be You Trust Your Fortune A Lot \\n Lets Begin Then\"\n)\nsleep(2)\nd_cards = []  # Initialising dealer's cards\np_cards = []  # Initialising player's cards\nsleep(2)\nwhile len(d_cards) != 2:\n    random.shuffle(deck)\n    d_cards.append(deck.pop())\n    if len(d_cards) == 2:\n        print(\"The cards dealer has are X \", d_cards[1])\n\n# Displaying the Player's cards\nwhile len(p_cards) != 2:\n    random.shuffle",
        "middle": "(deck)\n    p_cards.append(deck.pop())\n    if len(p_cards) == 2:\n        print(\"The total of player is \", sum(p_cards))\n        print(\"The ",
        "suffix": "cards Player has are  \", p_cards)\n\nif sum(p_cards) > 21:\n    print(f\"You are BUSTED !\\n  {'*'*14}Dealer Wins !!{'*'*14}\\n\")\n    exit()\n\nif sum(d_cards) > 21:\n    print(f\"Dealer is BUSTED !\\n   {'*'*14} You are the Winner !!{'*'*18}\\n\")\n    exit()\n\nif sum(d_cards) == 21:\n    print(f\"{'*'*24}Dealer is the Winner !!{'*'*14}\")\n    exit()\n\nif sum(d_cards) == 21 and sum(p_cards) == 21:\n    print(f\"{'*'*17}The match is tie !!{'*'*25}\")\n    exit()\n\n\n# function to show the dealer's choice\ndef dealer_choice():\n    if sum(d_cards) < 17:\n        while sum(d_cards) < 17:\n            random.shuffle(deck)\n            d_cards.append(deck.pop())\n\n    print(\"Dealer has total \" + str(sum(d_cards)) + \"with the cards \", d_cards)\n\n    if sum(p_cards) == sum(d_cards):\n        print(f\"{'*'*15}The match is tie !!{'*'*15}\")\n        exit()\n\n    if sum(d_cards) == 21:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*20}There is tie !!{'*'*26}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n    elif sum(d_cards) < 21:\n        if sum(p_cards) < 21 and sum(p_cards) < sum(d_cards):\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n        if sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        if 21 > sum(p_cards) > sum(d_cards):\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n\n    else:\n        if sum(p_cards) < 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        elif sum(p_cards) == 21:\n            print(f\"{'*'*22}Player is winner !!{'*'*22}\")\n        else:\n            print(f\"{'*'*23}Dealer is the Winner !!{'*'*18}\")\n\n\nwhile sum(p_cards) < 21:\n\n    # to continue the game again and again !!\n    k = input(\"Want to hit or stay?\\n Press 1 for hit and 0 for stay \")\n    if k == \"1\": #Ammended 1 to a string\n        random.shuffle(deck)\n        p_cards.append(deck.pop())\n        print(\"You have a total of \" + str(sum(p_cards)) + \" with the cards \", p_cards)\n        if sum(p_cards) > 21:\n            print(f'{\"*\"*13}You are BUSTED !{\"*\"*13}\\n Dealer Wins !!')\n        if sum(p_cards) == 21:\n            print(f'{\"*\"*19}You are the Winner !!{\"*\"*29}')\n\n    else:\n        dealer_choice()\n        break\n"
    },
    {
        "id": 14,
        "filename": "6.txt",
        "prefix": "\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")\n\n    def heapify(self, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        current = self.head\n        for _ in range(i):\n            current = current.next\n\n        if left < n and current.data < current.next.data:\n            largest = left\n\n        if right < n and current.data < current.next.data:\n            largest = right\n\n        if largest != i:\n            self.swap(i, largest)\n            self.heapify(n, largest)\n\n    def swap(self, i, j):\n        current_i = self.head\n        current_j = self.head\n\n        for _ in range(i):\n            current_i =",
        "middle": " current_i.next\n\n        for _ in range(j):\n            current_j = current_j.",
        "suffix": "next\n\n        current_i.data, current_j.data = current_j.data, current_i.data\n\n    def heap_sort(self):\n        n = 0\n        current = self.head\n        while current:\n            n += 1\n            current = current.next\n\n        for i in range(n // 2 - 1, -1, -1):\n            self.heapify(n, i)\n\n        for i in range(n - 1, 0, -1):\n            self.swap(0, i)\n            self.heapify(i, 0)\n\n# Example usage:\nlinked_list = LinkedList()\nlinked_list.push(12)\nlinked_list.push(11)\nlinked_list.push(13)\nlinked_list.push(5)\nlinked_list.push(6)\nlinked_list.push(7)\n\nprint(\"Original Linked List:\")\nlinked_list.print_list()\n\nlinked_list.heap_sort()\n\nprint(\"Sorted Linked List:\")\nlinked_list.print_list()\n"
    },
    {
        "id": 15,
        "filename": "6.txt",
        "prefix": "\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")\n\n    def heapify(self, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        current = self.head\n        for _ in range(i):\n            current = current.next\n\n        if left < n and current.data < current.next.data:\n            largest = left\n\n        if right < n and current.data < current.next.data:\n            largest = right\n\n        if largest != i:\n            self.swap(i, largest)\n ",
        "middle": "           self.",
        "suffix": "heapify(n, largest)\n\n    def swap(self, i, j):\n        current_i = self.head\n        current_j = self.head\n\n        for _ in range(i):\n            current_i = current_i.next\n\n        for _ in range(j):\n            current_j = current_j.next\n\n        current_i.data, current_j.data = current_j.data, current_i.data\n\n    def heap_sort(self):\n        n = 0\n        current = self.head\n        while current:\n            n += 1\n            current = current.next\n\n        for i in range(n // 2 - 1, -1, -1):\n            self.heapify(n, i)\n\n        for i in range(n - 1, 0, -1):\n            self.swap(0, i)\n            self.heapify(i, 0)\n\n# Example usage:\nlinked_list = LinkedList()\nlinked_list.push(12)\nlinked_list.push(11)\nlinked_list.push(13)\nlinked_list.push(5)\nlinked_list.push(6)\nlinked_list.push(7)\n\nprint(\"Original Linked List:\")\nlinked_list.print_list()\n\nlinked_list.heap_sort()\n\nprint(\"Sorted Linked List:\")\nlinked_list.print_list()\n"
    },
    {
        "id": 16,
        "filename": "6.txt",
        "prefix": "\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")\n\n    def heapify(self, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        current = self.head\n        for _ in range(i):\n            current = current.next\n\n        if left < n and current.data < current.next.",
        "middle": "data:\n            largest = left\n\n        if right < n and current.data < current.next.data:\n            largest = right\n\n        if largest",
        "suffix": " != i:\n            self.swap(i, largest)\n            self.heapify(n, largest)\n\n    def swap(self, i, j):\n        current_i = self.head\n        current_j = self.head\n\n        for _ in range(i):\n            current_i = current_i.next\n\n        for _ in range(j):\n            current_j = current_j.next\n\n        current_i.data, current_j.data = current_j.data, current_i.data\n\n    def heap_sort(self):\n        n = 0\n        current = self.head\n        while current:\n            n += 1\n            current = current.next\n\n        for i in range(n // 2 - 1, -1, -1):\n            self.heapify(n, i)\n\n        for i in range(n - 1, 0, -1):\n            self.swap(0, i)\n            self.heapify(i, 0)\n\n# Example usage:\nlinked_list = LinkedList()\nlinked_list.push(12)\nlinked_list.push(11)\nlinked_list.push(13)\nlinked_list.push(5)\nlinked_list.push(6)\nlinked_list.push(7)\n\nprint(\"Original Linked List:\")\nlinked_list.print_list()\n\nlinked_list.heap_sort()\n\nprint(\"Sorted Linked List:\")\nlinked_list.print_list()\n"
    },
    {
        "id": 17,
        "filename": "6.txt",
        "prefix": "\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")\n\n    def heapify(self, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        current = self.head\n        for _ in range(i):\n            current = current.next\n\n        if left < n and current.data < current.next.data:\n            largest = left\n\n        if right < n and current.data < current.next.data:\n            largest = right\n\n        if largest != i:\n            self.swap(i, largest)\n            self.heapify(n, largest)\n\n    def swap(self, i, j):\n        current_i = self.head\n        current_j = self.head\n\n        for _ in range(i):\n            current_i = current_i.next\n\n        for _ in range(j):\n            current_j = current_j.next\n\n        current_i.data, current_j.data = current_j.data, current_i.data\n\n    def heap_sort(self):\n        n = 0\n        current = self.head\n        while current:\n            n += 1\n            current = current.next\n\n        for i in range(n // 2 - 1, -1, -1):\n            self.heapify(n, i)\n\n        for i in range(n - 1, 0, -1):\n            self.swap(0, i)\n            self.heapify(i, 0)\n\n# Example usage:\nlinked_list = LinkedList()\nlinked_list.push(12)\nlinked_list.push(11)\nlinked_list.push(13)\nlinked_list.push(5)\nlinked_list.push(6)\nlinked_list.push(7)\n\nprint(\"Original Linked List:\")\nlinked_list.print_list()\n\nlinked_list.heap_sort()\n\nprint(\"Sorted Linked ",
        "middle": "List:\")\nlinked_list",
        "suffix": ".print_list()\n"
    },
    {
        "id": 18,
        "filename": "6.txt",
        "prefix": "\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")\n\n    def heapify(self, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        current = self.head\n        for _ in range(i):\n            current = current.next\n\n        if left < n and current.data < current.next.data:\n            largest = left\n\n        if right < n and current.data < current.next.data:\n            largest = right\n\n        if largest != i:\n            self.swap(i, largest)\n            self.heapify(n, largest)\n\n    def swap(self,",
        "middle": " i, j):\n        current_i = self.head\n        current_j = self.",
        "suffix": "head\n\n        for _ in range(i):\n            current_i = current_i.next\n\n        for _ in range(j):\n            current_j = current_j.next\n\n        current_i.data, current_j.data = current_j.data, current_i.data\n\n    def heap_sort(self):\n        n = 0\n        current = self.head\n        while current:\n            n += 1\n            current = current.next\n\n        for i in range(n // 2 - 1, -1, -1):\n            self.heapify(n, i)\n\n        for i in range(n - 1, 0, -1):\n            self.swap(0, i)\n            self.heapify(i, 0)\n\n# Example usage:\nlinked_list = LinkedList()\nlinked_list.push(12)\nlinked_list.push(11)\nlinked_list.push(13)\nlinked_list.push(5)\nlinked_list.push(6)\nlinked_list.push(7)\n\nprint(\"Original Linked List:\")\nlinked_list.print_list()\n\nlinked_list.heap_sort()\n\nprint(\"Sorted Linked List:\")\nlinked_list.print_list()\n"
    },
    {
        "id": 19,
        "filename": "7.txt",
        "prefix": "\n\"\"\"\nGiven a linked list with head pointer,\nsort the linked list using quicksort technique without using any extra space\nTime complexity: O(NlogN), Space complexity: O(1)\n\"\"\"\nfrom __future__ import annotations\n\n\nclass Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    # method to insert nodes at the start of linkedlist\n    def insert(self, new_data: int) -> None:\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # method to print the ",
        "middle": "linkedlist\n    def printLL(self) -> None:\n        temp = self.head\n        if temp == None:\n            return 'Linked List",
        "suffix": " is empty'\n        while temp.next:\n            print(temp.data, '->', end='')\n            temp = temp.next\n        print(temp.data)\n        return\n\n# Partition algorithm with pivot as first element\n\n\ndef partition(start, end):\n    if start == None or start.next == None:\n        return start\n    prev, curr = start, start.next\n    pivot = prev.data\n    while curr != end:\n        if curr.data < pivot:\n            prev = prev.next\n            temp = prev.data\n            prev.data = curr.data\n            curr.data = temp\n        curr = curr.next\n    temp = prev.data\n    prev.data = start.data\n    start.data = temp\n    return prev\n\n\n# recursive quicksort for function calls\ndef quicksort_LL(start, end):\n    if start != end:\n        pos = partition(start, end)\n        quicksort_LL(start, pos)\n        quicksort_LL(pos.next, end)\n        return\n\n\nif __name__ == \"__main__\":\n    ll = LinkedList()\n    print(\"Enter the space seperated values of numbers to be inserted in linkedlist prompted below:\")\n    arr = list(map(int, input().split()))\n    for num in arr:\n        ll.insert(num)\n    print(\"Linkedlist before sorting:\")\n    ll.printLL()\n    quicksort_LL(ll.head, None)\n    print('Linkedlist after sorting: ')\n    ll.printLL()\n"
    },
    {
        "id": 20,
        "filename": "7.txt",
        "prefix": "\n\"\"\"\nGiven a linked list with head pointer,\nsort the linked list using quicksort technique without using any extra space\nTime complexity: O(NlogN), Space complexity: O(1)\n\"\"\"\nfrom __future__ import annotations\n\n\nclass Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    # method to insert nodes at the start of linkedlist\n    def ",
        "middle": "insert(self, new_data: int) -> None:\n        new_node = Node(new_data)\n        new_node.",
        "suffix": "next = self.head\n        self.head = new_node\n\n    # method to print the linkedlist\n    def printLL(self) -> None:\n        temp = self.head\n        if temp == None:\n            return 'Linked List is empty'\n        while temp.next:\n            print(temp.data, '->', end='')\n            temp = temp.next\n        print(temp.data)\n        return\n\n# Partition algorithm with pivot as first element\n\n\ndef partition(start, end):\n    if start == None or start.next == None:\n        return start\n    prev, curr = start, start.next\n    pivot = prev.data\n    while curr != end:\n        if curr.data < pivot:\n            prev = prev.next\n            temp = prev.data\n            prev.data = curr.data\n            curr.data = temp\n        curr = curr.next\n    temp = prev.data\n    prev.data = start.data\n    start.data = temp\n    return prev\n\n\n# recursive quicksort for function calls\ndef quicksort_LL(start, end):\n    if start != end:\n        pos = partition(start, end)\n        quicksort_LL(start, pos)\n        quicksort_LL(pos.next, end)\n        return\n\n\nif __name__ == \"__main__\":\n    ll = LinkedList()\n    print(\"Enter the space seperated values of numbers to be inserted in linkedlist prompted below:\")\n    arr = list(map(int, input().split()))\n    for num in arr:\n        ll.insert(num)\n    print(\"Linkedlist before sorting:\")\n    ll.printLL()\n    quicksort_LL(ll.head, None)\n    print('Linkedlist after sorting: ')\n    ll.printLL()\n"
    },
    {
        "id": 21,
        "filename": "7.txt",
        "prefix": "\n\"\"\"\nGiven a linked list with head pointer,\nsort the linked list using quicksort technique without using any extra space\nTime complexity: O(NlogN), Space complexity: O(1)\n\"\"\"\nfrom __future__ import annotations\n\n\nclass Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    # method to insert nodes at the start of linkedlist\n    def insert(self, new_data: int) -> None:\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # method to print the linkedlist\n    def printLL(self) -> None:\n        temp = self.head\n        if temp == None:\n            return 'Linked List is empty'\n        while temp.next:\n            print(temp.data, '->', end='')\n            temp = temp.next\n        print(temp.data)\n        return\n\n# Partition algorithm with pivot as first element\n\n\ndef partition(start, end):\n    if start == None or start.next == None:\n        return start\n    prev, curr = start, start.next\n    pivot = prev.data\n    while curr != end:\n        if curr.data < pivot:\n            prev = prev.next\n            temp = prev.data\n            prev.data = curr.data\n            curr.data = temp\n        curr = curr.next\n    temp = prev.data",
        "middle": "\n    prev.data = start.data\n    start.data = temp\n    return prev\n\n\n# recursive",
        "suffix": " quicksort for function calls\ndef quicksort_LL(start, end):\n    if start != end:\n        pos = partition(start, end)\n        quicksort_LL(start, pos)\n        quicksort_LL(pos.next, end)\n        return\n\n\nif __name__ == \"__main__\":\n    ll = LinkedList()\n    print(\"Enter the space seperated values of numbers to be inserted in linkedlist prompted below:\")\n    arr = list(map(int, input().split()))\n    for num in arr:\n        ll.insert(num)\n    print(\"Linkedlist before sorting:\")\n    ll.printLL()\n    quicksort_LL(ll.head, None)\n    print('Linkedlist after sorting: ')\n    ll.printLL()\n"
    },
    {
        "id": 22,
        "filename": "7.txt",
        "prefix": "\n\"\"\"\nGiven a linked list with head pointer,\nsort the linked list using quicksort technique without using any extra space\nTime complexity: O(NlogN), Space complexity: O(1)\n\"\"\"\nfrom __future__ import annotations\n\n\nclass Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    # method to insert nodes at the start of linkedlist\n    def insert(self, new_data: int) -> None:\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # method to print the linkedlist\n    def printLL(self) -> None:\n        temp = self.head\n        if temp == None:\n            return 'Linked List is empty'\n        while temp.next:\n            print(temp.data, '->', end='')\n            temp = temp.next\n        print(temp.data)\n        return\n\n# Partition algorithm with pivot as first element\n\n\ndef partition(start, end):\n    if start == None or start.next == None:\n        return start\n    prev, curr = start, start.next\n    pivot = prev.data\n    while curr != end:\n        if curr.data < pivot:\n            prev = prev.next\n            temp = prev.data\n            prev.data = curr.data\n            curr.data = temp\n        curr = curr.next\n    temp = prev.data\n    prev.data = start.data\n    start.data = temp\n    return prev\n\n\n# recursive quicksort for function calls\ndef quicksort_LL(start, end):\n    if start != end:\n        pos = partition(start, end)\n        quicksort_LL(start, pos)\n        quicksort_LL(pos.next, end)\n        return\n\n\nif __name__ == \"__main__\":\n    ll = LinkedList()\n    print(\"Enter the space seperated values of ",
        "middle": "numbers to be",
        "suffix": " inserted in linkedlist prompted below:\")\n    arr = list(map(int, input().split()))\n    for num in arr:\n        ll.insert(num)\n    print(\"Linkedlist before sorting:\")\n    ll.printLL()\n    quicksort_LL(ll.head, None)\n    print('Linkedlist after sorting: ')\n    ll.printLL()\n"
    },
    {
        "id": 23,
        "filename": "7.txt",
        "prefix": "\n\"\"\"\nGiven a linked list with head pointer,\nsort the linked list using quicksort technique without using any extra space\nTime complexity: O(NlogN), Space complexity: O(1)\n\"\"\"\nfrom __future__ import annotations\n\n\nclass Node:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    # method to insert nodes at the start of linkedlist\n    def insert(self, new_data: int) -> None:\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # method to print the linkedlist\n    def printLL(self) -> None:\n        temp = self.head\n        if temp == None:\n            return 'Linked List is empty'\n        while temp.next:\n            print(temp.data, '->', end='')\n            temp = temp.next\n        print(temp.data)\n        return\n\n# Partition algorithm with pivot as first element\n\n\ndef partition(start, end):\n    if start == None or start.next == None:\n        return start\n    prev, curr = start, start.next\n    pivot = prev.data\n    while curr != end:\n        if curr.data < pivot:\n            prev = prev.next\n            temp = prev.data\n            prev.data = curr.data\n            curr.data = temp\n        curr = curr.next\n    temp = prev.data\n    prev.data = start.data\n    start.data = temp\n    return prev\n\n\n# recursive quicksort for function calls\ndef quicksort_LL(start, end):\n    if start != end:\n        pos = partition(start, end)\n        quicksort_LL(start, pos)\n      ",
        "middle": "  quicksort_LL",
        "suffix": "(pos.next, end)\n        return\n\n\nif __name__ == \"__main__\":\n    ll = LinkedList()\n    print(\"Enter the space seperated values of numbers to be inserted in linkedlist prompted below:\")\n    arr = list(map(int, input().split()))\n    for num in arr:\n        ll.insert(num)\n    print(\"Linkedlist before sorting:\")\n    ll.printLL()\n    quicksort_LL(ll.head, None)\n    print('Linkedlist after sorting: ')\n    ll.printLL()\n"
    },
    {
        "id": 24,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('",
        "middle": "Number of ",
        "suffix": "samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 25,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name =",
        "middle": " class_names[",
        "suffix": "label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 26,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts",
        "middle": " = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name",
        "suffix": " = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 27,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n ",
        "middle": "       for label in labels:\n            class_name = class_names",
        "suffix": "[label]\n            class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 28,
        "filename": "3.txt",
        "prefix": "def visualize_classes(data):\n\n    class_counts = count_classes(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_classes_v2(data):\n\n    class_counts = count_classes_v2(data)\n\n    plt.figure(figsize=(10, 6))\n    plt.bar(class_counts.keys(), class_counts.values(), color='skyblue')\n    plt.xlabel('Classes')\n    plt.ylabel('Number of samples')\n    plt.xticks(rotation=45)\n    plt.show()\n\ndef visualize_sample_images(data):\n    plt.figure(figsize=(24, 12))\n    for images, labels in data.take(1):\n        for i in range(32):\n            plt.subplot(4, 8, i + 1)\n            plt.imshow(np.array(images[i]).astype(\"uint8\"))\n            plt.title(class_names[labels[i]])\n            plt.axis(\"off\")\n\ndef count_classes(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for images, labels in data:\n        for label in labels:\n            class_name = class_names[label]\n            class_counts[class_name] += 1\n\n    return ",
        "middle": "class_counts\n\ndef count_classes_v2(data):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for image, label",
        "suffix": " in data:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts\n\ndef count_classes_in_predicted_labels(y_pred):\n    class_counts = {class_name: 0 for class_name in class_names}\n    for label in y_pred:\n        class_name = class_names[label]\n        class_counts[class_name] += 1\n\n    return class_counts"
    },
    {
        "id": 29,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test",
        "middle": ")\npredictions = ",
        "suffix": "label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 30,
        "filename": "2.txt",
        "prefix": "import xgboost ",
        "middle": "as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics ",
        "suffix": "import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 31,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.",
        "middle": "model_selection import train_test_split\nfrom sklearn.metrics import classification_report\n",
        "suffix": "from sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 32,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=",
        "middle": "0",
        "suffix": ").to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel = xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 33,
        "filename": "2.txt",
        "prefix": "import xgboost as xgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.preprocessing import LabelEncoder\nfeatures=pd.read_csv(\"features.csv\",index_col=0).to_numpy()\nlabels=pd.read_csv(\"labels.csv\",index_col=0).to_numpy()\n\ntarget_names = [BIOMES.get(int(label), str(label)) for label in labels]\n\n\nX_train, X_test, y_train, y_test = train_test_split(features, target_names, test_size=0.2, random_state=42)\nlabel_encoder = LabelEncoder()\n\n\ny_train_encoded = label_encoder.fit_transform(y_train)\ny_test_encoded = label_encoder.transform(y_test)\n\nmodel",
        "middle": " =",
        "suffix": " xgb.XGBClassifier(objective='multi:softmax', num_class=len(np.unique(y_train)))\nmodel.fit(X_train, y_train_encoded)\n\npredictions = model.predict(X_test)\npredictions = label_encoder.inverse_transform(predictions)\nreport = classification_report(y_test, predictions)\nprint(\"Classification Report:\\n\", report)"
    },
    {
        "id": 34,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.",
        "middle": "messages",
        "suffix": "}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 35,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n     ",
        "middle": "                   limit",
        "suffix": "=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 36,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    '",
        "middle": "file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': ",
        "suffix": "media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 37,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n",
        "middle": "            print(f\"",
        "suffix": "Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message = media_groups[message.grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    },
    {
        "id": 38,
        "filename": "1.txt",
        "prefix": "from flask import Flask, render_template\nfrom dotenv import find_dotenv, load_dotenv\nfrom telethon import TelegramClient\nfrom telethon.tl.types import (\n    MessageMediaPhoto,\n    MessageMediaDocument,\n    MessageMediaWebPage,\n    WebPageEmpty,\n    WebPage\n)\n\nimport os\nimport asyncio\nimport threading\nimport traceback\nimport json\n\n# Initialize the Flask app in the global scope\napp = Flask(__name__)\n\n\nclass ChannelViewer:\n    def __init__(self):\n        self.channel_username = 'onlinerby'  # Replace with the target channel's username\n        self.messages = []\n        self.messages_lock = threading.Lock()\n        self.load_environment_variables()\n\n        # Store API credentials\n        self.api_id = os.getenv('API_ID')\n        self.api_hash = os.getenv('API_HASH')\n\n        # Initialize variables\n        self.last_message_id = 0  # To keep track of the last processed message ID\n\n        # Load existing messages from file\n        self.load_messages()\n\n        # Start the background thread\n        self.start_fetching_messages()\n\n    def load_environment_variables(self):\n        \"\"\"\n        Load environment variables from a .env file.\n        \"\"\"\n        try:\n            dotenv_path = find_dotenv()\n            if not dotenv_path:\n                raise FileNotFoundError(\".env file not found\")\n            load_dotenv(dotenv_path)\n            print(f\"Environment variables loaded from {dotenv_path}\")\n        except Exception as e:\n            print(f\"Error loading .env file: {e}\")\n            raise\n\n    def load_messages(self):\n        \"\"\"\n        Load messages from 'messages.json' if it exists.\n        \"\"\"\n        try:\n            with open('messages.json', 'r', encoding='utf-8') as f:\n                self.messages = json.load(f)\n            if self.messages:\n                # Update last_message_id with the highest message ID\n                self.last_message_id = max(msg['id'] for msg in self.messages)\n            print(f\"Loaded {len(self.messages)} messages from messages.json.\")\n        except FileNotFoundError:\n            print(\"messages.json not found. Starting with an empty message list.\")\n        except Exception as e:\n            print(f\"Error loading messages: {e}\")\n\n    def save_messages(self):\n        \"\"\"\n        Save messages to 'messages.json'.\n        \"\"\"\n        try:\n            with open('messages.json', 'w', encoding='utf-8') as f:\n                json.dump(self.messages, f, ensure_ascii=False, indent=4)\n            print(f\"Saved {len(self.messages)} messages to messages.json.\")\n        except Exception as e:\n            print(f\"Error saving messages: {e}\")\n\n    def start_fetching_messages(self):\n        print('Starting background thread to fetch messages.')\n        fetch_thread = threading.Thread(target=self.fetch_messages)\n        fetch_thread.daemon = True  # Daemonize thread to exit when main program exits\n        fetch_thread.start()\n        print('Background thread started.')\n\n    def fetch_messages(self):\n        print('fetch_messages: Started fetching messages.')\n        # Set up a new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n        async def main():\n            try:\n                print('fetch_messages: Starting main function.')\n\n                # Initialize the Telegram client in this thread's event loop\n                self.client = TelegramClient('session_name', self.api_id, self.api_hash, loop=loop)\n\n                # Start the client (connect and authenticate)\n                await self.client.start()\n                print('Telegram client started in background thread.')\n\n                # Initialize variables\n                offset_id = 0  # Start from the latest message\n                limit = 50  # Number of messages to fetch in each batch\n\n                while True:\n                    print('Fetching new messages...')\n                    new_messages = []\n                    media_groups = {}\n\n                    # Fetch messages in batches\n                    messages = await self.client.get_messages(\n                        self.channel_username,\n                        limit=limit,\n                        offset_id=offset_id\n                    )\n\n                    if not messages:\n                        print('No new messages found.')\n                        await asyncio.sleep(5)  # Wait before checking again\n                        continue\n\n                    for message in reversed(messages):  # Process from oldest to newest\n                        print(f'Processing message ID {message.id}')\n                        message_data = {\n                            'id': message.id,\n                            'text': message.text or '',\n                            'date': message.date.strftime('%Y-%m-%d %H:%M:%S'),\n                            'sender': message.sender_id,\n                            'media': [],\n                            'media_type': None,\n                            'grouped_id': message.grouped_id,\n                        }\n\n                        # Check if the message has media\n                        if message.media:\n                            print(f'Message ID {message.id} has media.')\n                            # Ensure the directory exists\n                            media_dir = 'static/media/'\n                            os.makedirs(media_dir, exist_ok=True)\n\n                            # Initialize variables\n                            media_filename = None\n                            media_item = {}\n\n                            # Handle different media types\n                            if isinstance(message.media, MessageMediaPhoto):\n                                # For photos\n                                file_extension = '.jpg'\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded photo for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Photo for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'photo',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaDocument):\n                                # For documents (including videos, audio, etc.)\n                                file_extension = self.get_media_extension(message)\n                                media_filename = f\"{message.id}{file_extension}\"\n                                file_path = os.path.join(media_dir, media_filename)\n\n                                if not os.path.exists(file_path):\n                                    await message.download_media(file=file_path)\n                                    print(f'Downloaded document for message ID {message.id}: {media_filename}')\n                                else:\n                                    print(f'Document for message ID {message.id} already exists: {media_filename}')\n\n                                media_item = {\n                                    'file_path': file_path,\n                                    'media_type': 'document',\n                                    'media_filename': media_filename\n                                }\n\n                            elif isinstance(message.media, MessageMediaWebPage):\n                                # Handle web page previews\n                                print(f'Message ID {message.id} contains a web page preview.')\n                                webpage = message.media.webpage\n\n                                if isinstance(webpage, WebPage):\n                                    # Full web page preview\n                                    message_data['webpage'] = {\n                                        'url': webpage.url,\n                                        'title': getattr(webpage, 'title', ''),\n                                        'description': getattr(webpage, 'description', '')\n                                    }\n                                    print(\n                                        f\"Extracted webpage info for message ID {message.id}: {message_data['webpage']}\")\n                                elif isinstance(webpage, WebPageEmpty):\n                                    # Empty web page preview\n                                    print(f'Message ID {message.id} contains an empty web page preview.')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n                                else:\n                                    # Other web page types\n                                    print(\n                                        f'Message ID {message.id} contains an unsupported web page type: {type(webpage)}')\n                                    message_data['webpage'] = {\n                                        'url': '',\n                                        'title': '',\n                                        'description': ''\n                                    }\n\n                                # Add to new_messages and skip further processing\n                                new_messages.append(message_data)\n                                continue  # Skip to next message\n\n                            else:\n                                # Unsupported media type\n                                print(f'Message ID {message.id} has unsupported media type: {type(message.media)}')\n                                continue  # Skip this message\n\n                            # Update message data\n                            if media_item:\n                                message_data['media'].append(media_item)\n                                message_data['media_type'] = media_item['media_type']\n\n                        # Group messages by grouped_id if they are part of a media group\n                        if message.grouped_id:\n                            print(f'Message ID {message.id} is part of group {message.grouped_id}')\n                            if message.grouped_id not in media_groups:\n                                # First message in the group; store the text (caption) if available\n                                media_groups[message.grouped_id] = message_data\n                            else:\n                                # Append media to existing group\n                                existing_message",
        "middle": " = media_groups[message.",
        "suffix": "grouped_id]\n                                existing_message['media'].extend(message_data['media'])\n                                # If the existing message doesn't have text, and current message has text, update it\n                                if not existing_message['text'] and message_data['text']:\n                                    existing_message['text'] = message_data['text']\n                                    print(\n                                        f'Updated text for media group {message.grouped_id}: \"{message_data[\"text\"]}\"')\n                        else:\n                            # Not part of a media group, add as individual message\n                            new_messages.append(message_data)\n\n                        # Update last_message_id\n                        if message.id > self.last_message_id:\n                            self.last_message_id = message.id\n\n                        # Update offset_id for the next batch\n                        offset_id = message.id\n\n                    # Add grouped messages to new_messages\n                    new_messages.extend(media_groups.values())\n\n                    # Sort messages by date (optional)\n                    new_messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    # Update the shared messages list\n                    with self.messages_lock:\n                        self.messages.extend(new_messages)\n                        # Remove duplicates based on message ID\n                        self.messages = list({msg['id']: msg for msg in self.messages}.values())\n                        # Sort messages after merging\n                        self.messages.sort(key=lambda x: x['date'], reverse=True)\n\n                    print(f'Fetched and processed {len(new_messages)} new messages.')\n\n                    # Save messages to file\n                    self.save_messages()\n\n                    # Yield control to the event loop\n                    await asyncio.sleep(1)  # Adjust sleep time as needed\n\n            except Exception as e:\n                print(f'An error occurred in fetch_messages: {e}')\n                traceback.print_exc()\n\n        # Run the async function in the event loop\n        try:\n            loop.run_until_complete(main())\n        finally:\n            # Properly disconnect the client\n            self.client.disconnect()\n            loop.close()\n\n    def get_media_extension(self, message):\n        \"\"\"\n        Get the file extension for the media.\n        \"\"\"\n        if message.photo:\n            return '.jpg'\n        elif message.video:\n            return '.mp4'\n        elif message.document:\n            # Get the extension from the mime type or file name\n            mime_type = message.document.mime_type\n            if mime_type == 'image/jpeg':\n                return '.jpg'\n            elif mime_type == 'image/png':\n                return '.png'\n            elif mime_type == 'video/mp4':\n                return '.mp4'\n            else:\n                # Extract extension from file name\n                if message.file and message.file.name:\n                    return os.path.splitext(message.file.name)[1]\n                else:\n                    return ''\n        else:\n            return ''\n\n    def get_channel_messages(self):\n        with self.messages_lock:\n            return self.messages.copy()\n\n\n# Instantiate the ChannelViewer class\nviewer = ChannelViewer()\n\n\n@app.route('/')\ndef index():\n    print('Received request for /')\n    messages = viewer.get_channel_messages()\n    print(f\"Number of messages to display: {len(messages)}\")\n    return render_template('index.html', messages=messages)\n\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)"
    }
]